<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#9191F2',
                        success: '#4CAF50',
                        warning: '#FFC107',
                        danger: '#F44336',
                        light: {
                            background: '#FFFFFF',
                            text: '#333333',
                            card: '#F5F5F5',
                            border: '#E0E0E0'
                        },
                        dark: {
                            background: '#181818',
                            text: '#E0E0E0',
                            card: '#262626',
                            border: '#404040'
                        }
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
</head>
<body class="min-h-screen bg-light-background dark:bg-dark-background text-light-text dark:text-dark-text transition-colors duration-200">
    <div class="container mx-auto px-4 py-6 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-primary mb-2">Reading Tracker</h1>
            <p class="text-gray-600 dark:text-gray-400">Build your reading habit one page at a time</p>
        </header>

        <!-- Tab Navigation -->
        <div class="mb-6 border-b border-light-border dark:border-dark-border">
            <nav class="flex overflow-x-auto whitespace-nowrap">
                <button class="tab-btn active px-4 py-2 font-medium" data-tab="dashboard">Dashboard</button>
                <button class="tab-btn px-4 py-2 font-medium" data-tab="books">Books</button>
                <button class="tab-btn px-4 py-2 font-medium" data-tab="stats">Stats</button>
                <button class="tab-btn px-4 py-2 font-medium" data-tab="achievements">Achievements</button>
                <button class="tab-btn px-4 py-2 font-medium" data-tab="insights">Insights</button>
                <button class="tab-btn px-4 py-2 font-medium" data-tab="settings">Settings</button>
                <button class="tab-btn px-4 py-2 font-medium" data-tab="rules">Rules</button>
            </nav>
        </div>

        <!-- Tab Content -->
        <div class="tab-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-pane active">
                <!-- Daily Target Card -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-3 flex items-center justify-between">
                        <span>Daily Target</span>
                        <span id="daily-target-value" class="text-primary">10</span>
                    </h2>
                    <p class="text-center text-lg mb-4">Read at least <span id="target-pages" class="font-bold">10</span> pages per day</p>
                    
                    <div id="daily-progress" class="mb-3">
                        <div class="flex justify-between mb-1">
                            <span>Progress</span>
                            <span id="progress-text">0/10</span>
                        </div>
                        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                            <div id="progress-bar" class="bg-primary rounded-full h-4" style="width: 0%"></div>
                        </div>
                    </div>

                    <div id="already-logged" class="hidden mb-4">
                        <div class="text-center py-2 text-success font-medium">
                            You've already logged your reading for today!
                        </div>
                    </div>

                    <div id="log-form" class="mb-4">
                        <div class="flex flex-col md:flex-row gap-3 mb-3">
                            <div class="flex-grow">
                                <label for="pages-read" class="block mb-1">Pages Read Today</label>
                                <input type="number" id="pages-read" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base" min="0">
                            </div>
                            <div class="flex-grow">
                                <label for="book-selector" class="block mb-1">Book</label>
                                <select id="book-selector" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                                    <option value="">Select a book</option>
                                </select>
                            </div>
                        </div>
                        <div class="flex space-x-2">
                            <button id="log-reading" class="flex-grow bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                                Log Reading
                            </button>
                            <button id="use-buffer" class="bg-warning hover:bg-amber-500 text-black font-medium py-2 px-4 rounded-md transition-colors" disabled>
                                Use Buffer
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Stats Card -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Stats Tracking</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="stat-box">
                            <span class="font-medium">Daily Streak</span>
                            <div class="flex items-center">
                                <span id="streak-counter" class="text-xl font-bold">0</span>
                                <span class="text-gray-600 dark:text-gray-400 ml-1"> / <span id="streak-cycle">10</span> days</span>
                            </div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Free Pass</span>
                            <div class="flex items-center">
                                <span id="free-pass" class="text-xl font-bold">1</span>
                                <span class="text-gray-600 dark:text-gray-400 ml-1"> / 1 per streak cycle</span>
                            </div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Buffer Pages</span>
                            <div class="flex items-center">
                                <span id="buffer-pages" class="text-xl font-bold">0</span>
                                <span class="text-gray-600 dark:text-gray-400 ml-1"> / <span id="max-buffer">20</span></span>
                            </div>
                        </div>
			<div class="stat-box">
    			    <span class="font-medium">Max Daily Buffer</span>
    			    <div class="flex items-center">
        			<span id="max-daily-buffer" class="text-xl font-bold">5</span>
        			<span class="text-gray-600 dark:text-gray-400 ml-1">pages</span>
    			    </div>
			</div>
                        <div class="stat-box">
                            <span class="font-medium">Weekly Buffer Uses</span>
                            <div class="flex items-center">
                                <span id="buffer-uses" class="text-xl font-bold">0</span>
                                <span class="text-gray-600 dark:text-gray-400 ml-1"> / <span id="max-buffer-uses">2</span> per week</span>
                            </div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Buffer Decay Countdown</span>
                            <div class="flex items-center">
                                <span id="buffer-decay" class="text-xl font-bold">14</span>
                                <span class="text-gray-600 dark:text-gray-400 ml-1"> days</span>
                            </div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Completed Streaks</span>
                            <div class="flex items-center">
                                <span id="completed-streaks" class="text-xl font-bold">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Current Streak Card -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Current Streak</h2>
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <span class="text-2xl font-bold" id="consecutive-days">0</span>
                            <span class="text-gray-600 dark:text-gray-400 ml-1">consecutive days</span>
                        </div>
                        <div class="text-right">
                            <span class="text-gray-600 dark:text-gray-400">Longest Streak: </span>
                            <span class="font-bold" id="longest-consecutive-days">0</span>
                        </div>
                    </div>
                    <div class="w-full overflow-x-auto pb-2">
                        <div id="streak-heatmap" class="flex gap-1 min-w-max"></div>
                    </div>
                </div>

                <!-- Prestige Card (only shows when eligible) -->
                <div id="prestige-card" class="hidden mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md border-2 border-yellow-500">
                    <h2 class="text-2xl font-bold mb-3 text-yellow-500">Prestige Available!</h2>
                    <p class="mb-4">You've completed 5 streaks! Choose to prestige and select a permanent bonus or continue your current run.</p>
                    
                    <h3 class="font-bold mb-2">Choose One Permanent Bonus:</h3>
                    <div class="space-y-2 mb-4">
                        <div class="flex items-center">
                            <input type="radio" id="bonus-buffer" name="prestige-bonus" value="daily-buffer" class="mr-2">
                            <label for="bonus-buffer">Max. Daily Buffer: +1 page</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="bonus-capacity" name="prestige-bonus" value="buffer-capacity" class="mr-2">
                            <label for="bonus-capacity">Buffer Pages: +2 pages</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="bonus-decay" name="prestige-bonus" value="decay-reduction" class="mr-2">
                            <label for="bonus-decay">Buffer Decay Reduction: -5%</label>
                        </div>
                    </div>
                    
                    <div class="flex space-x-3">
                        <button id="prestige-btn" class="bg-yellow-500 hover:bg-yellow-600 text-black font-medium py-2 px-4 rounded-md transition-colors">
                            Prestige Now
                        </button>
                        <button id="continue-btn" class="bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                            Continue Current Run
                        </button>
                    </div>
                </div>
                
                <!-- Recent Achievements -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Recent Achievements</h2>
                        <button class="text-sm text-primary hover:underline" onclick="document.querySelector('.tab-btn[data-tab=\'achievements\']').click()">
                            View All
                        </button>
                    </div>
                    <div id="recent-achievements" class="space-y-2">
                        <p id="no-achievements" class="text-center text-gray-600 dark:text-gray-400 py-4">
                            No achievements unlocked yet. Keep reading!
                        </p>
                    </div>
                </div>
            </div>

            <!-- Books Tab -->
            <div id="books" class="tab-pane hidden">
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">My Books</h2>
                    
                    <div id="add-book-form" class="mb-6">
                        <h3 class="text-xl font-bold mb-3">Add New Book</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label for="book-title" class="block mb-1">Title</label>
                                <input type="text" id="book-title" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                            </div>
                            <div>
                                <label for="book-author" class="block mb-1">Author</label>
                                <input type="text" id="book-author" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                            </div>
                            <div>
                                <label for="book-genre" class="block mb-1">Genre</label>
                                <input type="text" id="book-genre" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                            </div>
                            <div>
                                <label for="book-total-pages" class="block mb-1">Total Pages</label>
                                <input type="number" id="book-total-pages" min="1" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                            </div>
                            <div>
                                <label for="book-current-page" class="block mb-1">Current Page</label>
                                <input type="number" id="book-current-page" min="0" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                            </div>
                        </div>
                        <button id="add-book-btn" class="bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                            Add Book
                        </button>
                    </div>
                    
                    <!-- Book Filters -->
                    <div class="mb-4 flex flex-wrap gap-2 items-center">
                        <span class="font-medium">Filter:</span>
                        <button id="filter-all" class="filter-btn active px-2 py-1 text-sm rounded-md bg-primary text-white">All</button>
                        <button id="filter-active" class="filter-btn px-2 py-1 text-sm rounded-md bg-gray-200 dark:bg-gray-700">Active</button>
                        <button id="filter-completed" class="filter-btn px-2 py-1 text-sm rounded-md bg-gray-200 dark:bg-gray-700">Completed</button>
                        
                        <div class="ml-auto">
                            <select id="sort-books" class="px-2 py-1 text-sm rounded-md border border-light-border dark:border-dark-border bg-white dark:bg-dark-background">
                                <option value="recent">Recently Added</option>
                                <option value="title">Title (A-Z)</option>
                                <option value="progress">Progress (High-Low)</option>
                                <option value="pages">Pages (High-Low)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="book-list" class="space-y-4">
                        <p id="no-books-message" class="text-center text-gray-600 dark:text-gray-400 py-4">No books added yet.</p>
                        <!-- Book entries will be added here dynamically -->
                    </div>
                </div>
                
                <!-- Genre Statistics -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Genre Breakdown</h2>
                    <div class="h-64">
                        <canvas id="genre-chart"></canvas>
                    </div>
                    <div id="genre-legend" class="mt-4 grid grid-cols-2 md:grid-cols-3 gap-2 text-sm"></div>
                </div>
            </div>

            <!-- Stats Tab -->
            <div id="stats" class="tab-pane hidden">
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Reading Statistics</h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <div class="stat-box">
                            <span class="font-medium">Pages Read (Total)</span>
                            <div class="text-xl font-bold" id="total-pages-read">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Days Tracked</span>
                            <div class="text-xl font-bold" id="days-tracked">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Average Pages Per Day</span>
                            <div class="text-xl font-bold" id="avg-pages-per-day">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Longest Streak</span>
                            <div class="text-xl font-bold" id="longest-streak">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Books Completed</span>
                            <div class="text-xl font-bold" id="books-completed">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Prestige Level</span>
                            <div class="text-xl font-bold" id="prestige-level">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Most Pages in One Day</span>
                            <div class="text-xl font-bold" id="max-pages-day">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Total Buffer Pages Earned</span>
                            <div class="text-xl font-bold" id="total-buffer-earned">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Unique Genres Read</span>
                            <div class="text-xl font-bold" id="unique-genres">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Free Passes Used</span>
                            <div class="text-xl font-bold" id="free-passes-used">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Streak Cycles Completed</span>
                            <div class="text-xl font-bold" id="streak-cycles-completed">0</div>
                        </div>
                        <div class="stat-box">
                            <span class="font-medium">Avg. Book Completion Time</span>
                            <div class="text-xl font-bold" id="avg-completion-time">N/A</div>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-xl font-bold mb-3">Reading History</h3>
                        
                        <!-- History Filters -->
                        <div class="mb-4 flex flex-wrap gap-2 items-center">
                            <span class="font-medium">View:</span>
                            <select id="history-period" class="px-3 py-1 text-sm rounded-md border border-light-border dark:border-dark-border bg-white dark:bg-dark-background">
                                <option value="30">Last 30 Days</option>
                                <option value="90">Last 90 Days</option>
                                <option value="180">Last 180 Days</option>
                                <option value="365">Last Year</option>
                                <option value="all">All Time</option>
                            </select>
                            
                            <select id="history-book" class="ml-2 px-3 py-1 text-sm rounded-md border border-light-border dark:border-dark-border bg-white dark:bg-dark-background">
                                <option value="all">All Books</option>
                                <!-- Book options will be added dynamically -->
                            </select>
                            
                            <select id="history-grouping" class="ml-2 px-3 py-1 text-sm rounded-md border border-light-border dark:border-dark-border bg-white dark:bg-dark-background">
                                <option value="day">Daily</option>
                                <option value="week">Weekly</option>
                                <option value="month">Monthly</option>
                            </select>
                        </div>
                        
                        <div class="chart-container" style="position: relative; height:300px;">
                            <canvas id="reading-chart"></canvas>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-xl font-bold mb-3">Weekly Reading Pattern</h3>
                        <div class="chart-container" style="position: relative; height:200px;">
                            <canvas id="weekly-pattern-chart"></canvas>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-xl font-bold mb-3">Streak Calendar</h3>
                        <div id="streak-calendar" class="grid grid-cols-7 gap-2">
                            <!-- Calendar will be generated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Reading Timeline -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Reading Timeline</h2>
                    <div id="reading-timeline" class="h-64 overflow-x-auto overflow-y-hidden">
                        <!-- Timeline will be drawn here -->
                    </div>
                </div>
            </div>

            <!-- Achievements Tab -->
            <div id="achievements" class="tab-pane hidden">
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Achievements</h2>
                        <div>
                            <span class="text-sm text-gray-600 dark:text-gray-400">Unlocked: </span>
                            <span id="achievements-count" class="font-medium">0/0</span>
                        </div>
                    </div>
                    
                    <!-- Achievement Categories -->
                    <div class="mb-4 overflow-x-auto">
                        <div class="flex gap-2 whitespace-nowrap">
                            <button class="achievement-category active px-3 py-1 text-sm rounded-full bg-primary text-white" data-category="all">All</button>
                            <button class="achievement-category px-3 py-1 text-sm rounded-full bg-gray-200 dark:bg-gray-700" data-category="basic">Beginner</button>
                            <button class="achievement-category px-3 py-1 text-sm rounded-full bg-gray-200 dark:bg-gray-700" data-category="reading">Reading</button>
                            <button class="achievement-category px-3 py-1 text-sm rounded-full bg-gray-200 dark:bg-gray-700" data-category="streak">Streaks</button>
                            <button class="achievement-category px-3 py-1 text-sm rounded-full bg-gray-200 dark:bg-gray-700" data-category="books">Books</button>
                            <button class="achievement-category px-3 py-1 text-sm rounded-full bg-gray-200 dark:bg-gray-700" data-category="prestige">Prestige</button>
                            <button class="achievement-category px-3 py-1 text-sm rounded-full bg-gray-200 dark:bg-gray-700" data-category="endgame">Endgame</button>
                        </div>
                    </div>
                    
                    <!-- Search & Filter -->
                    <div class="mb-4 flex gap-2">
                        <div class="relative flex-grow">
                            <input type="text" id="search-achievements" placeholder="Search achievements..." class="w-full pl-10 pr-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                            <svg class="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                            </svg>
                        </div>
                        
                        <select id="filter-achievements" class="px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                            <option value="all">All</option>
                            <option value="unlocked">Unlocked</option>
                            <option value="locked">Locked</option>
                        </select>
                    </div>
                    
                    <div id="achievements-list" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- Achievement cards will be added here dynamically -->
                    </div>
                </div>
            </div>
            
            <!-- Insights Tab -->
            <div id="insights" class="tab-pane hidden">
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Reading Insights</h2>
                    
                    <div id="insights-container" class="space-y-4">
                        <p id="no-insights" class="text-center text-gray-600 dark:text-gray-400 py-4">
                            Not enough data to generate insights yet. Keep reading!
                        </p>
                        <!-- Insights will be added here dynamically -->
                    </div>
                </div>
                
                <!-- Milestones -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Reading Milestones</h2>
                    
                    <div class="space-y-4">
                        <!-- Pages Milestone -->
                        <div>
                            <div class="flex justify-between mb-1">
                                <span class="font-medium">Total Pages</span>
                                <span id="pages-milestone-text">0/1,000</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3">
                                <div id="pages-milestone-bar" class="bg-primary rounded-full h-3" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <!-- Books Milestone -->
                        <div>
                            <div class="flex justify-between mb-1">
                                <span class="font-medium">Books Completed</span>
                                <span id="books-milestone-text">0/10</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3">
                                <div id="books-milestone-bar" class="bg-success rounded-full h-3" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <!-- Streak Milestone -->
                        <div>
                            <div class="flex justify-between mb-1">
                                <span class="font-medium">Consecutive Days</span>
                                <span id="streak-milestone-text">0/50</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3">
                                <div id="streak-milestone-bar" class="bg-yellow-500 rounded-full h-3" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <!-- Prestige Milestone -->
                        <div>
                            <div class="flex justify-between mb-1">
                                <span class="font-medium">Prestige Level</span>
                                <span id="prestige-milestone-text">0/5</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3">
                                <div id="prestige-milestone-bar" class="bg-purple-500 rounded-full h-3" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Next Achievements -->
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">Next Achievements</h2>
                        <button class="text-sm text-primary hover:underline" onclick="document.querySelector('.tab-btn[data-tab=\'achievements\']').click()">
                            View All
                        </button>
                    </div>
                    
                    <div id="next-achievements" class="space-y-4">
                        <!-- Next achievements will be added here dynamically -->
                    </div>
                </div>
            </div>
            
            <!-- Settings Tab -->
            <div id="settings" class="tab-pane hidden">
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Game Settings</h2>
                    
                    <div class="mb-6">
                        <h3 class="text-xl font-bold mb-3">Reading Target</h3>
                        <div class="flex flex-col gap-4">
                            <div>
                                <label for="setting-daily-target" class="block mb-1">Starting Daily Target</label>
                                <div class="flex gap-2">
                                    <input type="number" id="setting-daily-target" min="1" class="w-full px-3 py-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base">
                                    <button id="update-target" class="bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                                        Update
                                    </button>
                                </div>
                                <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                    This will apply the next time you prestige. Current target: <span id="current-daily-target">10</span>
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-xl font-bold mb-3">Data Management</h3>
                        <div class="flex flex-wrap gap-4">
                            <button id="export-data" class="bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                                Export Data
                            </button>
                            <button id="import-data" class="bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                                Import Data
                            </button>
                            <button id="reset-data" class="bg-danger hover:bg-red-500 text-white font-medium py-2 px-4 rounded-md transition-colors">
                                Reset Data
                            </button>
                        </div>
                        <div id="import-container" class="mt-4 hidden">
                            <textarea id="import-data-text" class="w-full h-32 p-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base" placeholder="Paste exported data here..."></textarea>
                            <div class="flex gap-2 mt-2">
                                <button id="confirm-import" class="bg-success hover:bg-green-600 text-white font-medium py-2 px-4 rounded-md transition-colors">
                                    Confirm Import
                                </button>
                                <button id="cancel-import" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition-colors">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-xl font-bold mb-3">App Information</h3>
                        <div class="space-y-2">
                            <p>
                                <span class="font-medium">Version:</span> 
                                <span id="app-version">1.1.0</span>
                            </p>
                            <p>
                                <span class="font-medium">Developer:</span> 
                                <span>CygRyu</span>
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Rules Tab -->
            <div id="rules" class="tab-pane hidden">
                <div class="mb-6 p-5 bg-light-card dark:bg-dark-card rounded-lg shadow-md">
                    <div class="mb-6">
    <h3 class="text-xl font-bold mb-3">Welcome to the Reading Tracker!</h3>
    <p class="mb-4">
        This little app is your personal cheerleader for building a rock-solid reading habit. üéâ Whether you're aiming to read 10 pages a day or 100, this tracker helps you stay on target with daily goals, streaks, and even a nifty buffer system for those "oops, I forgot to read" days. üìö‚ú®
    </p>
    <p class="mb-4">
        A quick heads-up: Right now, this tracker is a <strong>one-book wonder</strong>‚Äîit logs your progress for a single book from start to finish. Plus, you can only log your reading <strong>once per day</strong>, so make it count! No cheating by logging yesterday's pages today (we see you üëÄ).
    </p>
    <p>
        Ready to crush your reading goals? Let's get started! üöÄ
    </p>
</div>
                    
                    <div class="mb-6">
    <h3 class="text-xl font-bold mb-3">Rules & Mechanics</h3>

    <!-- Daily Target -->
    <details class="mb-4 p-4 bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <summary class="font-medium cursor-pointer">üìñ Daily Target</summary>
        <p class="mt-2">Set your daily reading goal and stick to it to keep your streak alive! Here's how it works:</p>
        <ul class="list-disc pl-5 space-y-1 mt-2">
            <li><strong>Starting Target:</strong> 10 pages (you can also set your own target, but it only applies on next prestige).</li>
            <li><strong>Target Increase:</strong> After completing a streak cycle, your target increases by 1 page. Challenge accepted? üí™</li>
            <li><strong>Streak Cycle:</strong> 10 days by default. Complete it, and you're on your way to greatness!</li>
        </ul>
    </details>

    <!-- Progress Rules -->
    <details class="mb-4 p-4 bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <summary class="font-medium cursor-pointer">üî• Progress Rules</summary>
        <p class="mt-2">Keep your streak alive by following these rules:</p>
        <ul class="list-disc pl-5 space-y-1 mt-2">
            <li><strong>Miss a Day?</strong> Your streak counter resets to 0. Ouch! üò¨</li>
            <li><strong>Free Pass:</strong> Got a free pass? Use it to save your streak when life gets in the way.</li>
            <li><strong>Free Pass Replenishment:</strong> Get 1 free pass at the start of each streak cycle. Use it wisely!</li>
        </ul>
    </details>

    <!-- Buffer System -->
    <details class="mb-4 p-4 bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <summary class="font-medium cursor-pointer">üè¶ Buffer System</summary>
        <p class="mt-2">Extra pages? Bank them for a rainy day! Here's how the buffer works:</p>
        <ul class="list-disc pl-5 space-y-1 mt-2">
            <li><strong>Banking Pages:</strong> Read more than your target? Bank the extra pages for later.</li>
            <li><strong>Max Daily Buffer:</strong> You can bank up to 5 pages per day (50% of your default target).</li>
            <li><strong>Weekly Buffer Uses:</strong> Use your buffer up to 2 times per week (or 3 if you skip prestiging!).</li>
            <li><strong>Buffer Decay:</strong> After 14 days, your buffer decays by 50% (rounded up). Don't let it go to waste!</li>
            <li><strong>Using the Buffer:</strong> When you use your buffer, the total pages read for the day cap at your target. Excess pages? Sorry, no banking those!</li>
        </ul>
    </details>

    <!-- Prestige System -->
    <details class="mb-4 p-4 bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <summary class="font-medium cursor-pointer">‚≠ê Prestige System</summary>
        <p class="mt-2">After completing 5 streaks, you can prestige and choose a permanent bonus. Here's what you get:</p>
        <ul class="list-disc pl-5 space-y-1 mt-2">
            <li><strong>Max Daily Buffer:</strong> +1 page (caps at +10).</li>
            <li><strong>Buffer Pages:</strong> +2 pages (caps at +25).</li>
            <li><strong>Buffer Decay Reduction:</strong> -5% (caps at -25% total reduction).</li>
        </ul>
        <p class="mt-2"><strong>Prestige Effects:</strong></p>
        <ul class="list-disc pl-5 space-y-1">
            <li>All stats reset to default, except for your chosen permanent bonus. Fresh start, but with a boost! üöÄ</li>
        </ul>
    </details>

    <!-- Non-Prestige Bonuses -->
    <details class="mb-4 p-4 bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <summary class="font-medium cursor-pointer">‚ú® Non-Prestige Bonuses</summary>
        <p class="mt-2">Not ready to prestige? No problem! Here's what you get if you skip it:</p>
        <ul class="list-disc pl-5 space-y-1 mt-2">
            <li><strong>Weekly Buffer Uses:</strong> Increase to 3 (permanent during the current run).</li>
            <li><strong>Buffer Decay Countdown:</strong> Extend to 20 days (permanent during the current run).</li>
        </ul>
        <p class="mt-2"><strong>Note:</strong> These bonuses only apply to your current run and don't carry over after prestiging.</p>
    </details>

    <!-- Key Notes -->
    <details class="mb-4 p-4 bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <summary class="font-medium cursor-pointer">üìå Key Notes</summary>
        <p class="mt-2">A few important things to keep in mind:</p>
        <ul class="list-disc pl-5 space-y-1 mt-2">
            <li><strong>Buffer Pages:</strong> Don't carry over during prestige. All buffer-related stats reset to default.</li>
            <li><strong>Streak Cycle:</strong> Completing a streak cycle increases your target and replenishes your free pass.</li>
            <li><strong>One Log Per Day:</strong> You can only log your reading once per day. When you log, the buffer decay countdown decreases by 1.</li>
            <li><strong>Prestige vs. Non-Prestige:</strong> Prestige offers permanent bonuses, while non-prestige gives you temporary boosts for your current run. Choose wisely!</li>
        </ul>
    </details>
</div>
                </div>
            </div>
        </div>
<!-- Add Support Button -->
<button id="supportButton" class="text-sm text-primary hover:underline">
    Support Reading Tracker
</button>
        <footer class="mt-8 text-center text-sm text-gray-600 dark:text-gray-400">
            <p>Developed by <span class="text-[#800000] font-medium">CygRyu</span> ‚Ä¢ Version <span id="footer-version">1.1.0</span></p>
        </footer>
    </div>
    
    <!-- Modal for Export Data -->
    <div id="export-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-light-background dark:bg-dark-background rounded-lg shadow-lg max-w-md w-full mx-4 p-6">
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold">Export Data</h3>
            <button id="close-export-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>
        <p class="mb-4 text-sm">Copy the text below to save your game data:</p>
        <textarea id="export-data-text" class="w-full h-32 p-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base" readonly></textarea>
        <div class="flex justify-between mt-4">
            <button id="copy-export-data" class="bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                Copy to Clipboard
            </button>
            <button id="done-export" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition-colors">
                Done
            </button>
        </div>
    </div>
</div>
    
    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-light-background dark:bg-dark-background rounded-lg shadow-lg max-w-md w-full mx-4 p-6">
            <div class="mb-4">
                <h3 id="confirmation-title" class="text-xl font-bold">Confirmation</h3>
                <p id="confirmation-message" class="mt-2">Are you sure you want to proceed?</p>
            </div>
            <div class="flex justify-end space-x-2">
                <button id="confirm-action" class="bg-danger hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md transition-colors">
                    Confirm
                </button>
                <button id="cancel-action" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </div>

	<!-- Export Modal -->
	<div id="export-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    	<div class="bg-light-background dark:bg-dark-background rounded-lg shadow-lg max-w-md w-full mx-4 p-6">
        	<div class="flex justify-between items-center mb-4">
            	<h3 class="text-xl font-bold">Export Data</h3>
            	<button id="close-export-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                	<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    	<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                	</svg>
            	</button>
        	</div>
        	<p class="mb-4 text-sm">Copy the text below to save your game data:</p>
        	<textarea id="export-data-text" class="w-full h-32 p-2 border border-light-border dark:border-dark-border rounded-md bg-white dark:bg-dark-background text-base" readonly></textarea>
        	<div class="flex justify-between mt-4">
            	<button id="copy-export-data" class="bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded-md transition-colors">
                	Copy to Clipboard
            	</button>
            	<button id="done-export" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition-colors">
                	Done
            	</button>
       	     </div>
    	   </div>
	</div>

<!-- Support Modal -->
<div id="supportModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">Support Reading Tracker</h2>
            <button id="closeSupportModal" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="mb-6">
            <p class="mb-4">If you're enjoying Reading Tracker and would like to support its development, consider the following options:</p>
            
            <div class="grid grid-cols-1 gap-4">
                <a href="" target="_blank" class="btn px-4 py-3 rounded bg-blue-600 hover:bg-blue-700 text-white flex items-center justify-center">
                    <i class="fab fa-patreon mr-2"></i> Support on Patreon
                </a>
                
                <a href="https://ko-fi.com/cygryu" target="_blank" class="btn px-4 py-3 rounded bg-purple-600 hover:bg-purple-700 text-white flex items-center justify-center">
                    <i class="fas fa-coffee mr-2"></i> Buy Me a Coffee
                </a>
                
                <a href="https://paypal.me/sofiansu?country.x=ID&locale.x=en_US" target="_blank" class="btn px-4 py-3 rounded bg-yellow-600 hover:bg-yellow-700 text-white flex items-center justify-center">
                    <i class="fas fa-heart mr-2"></i> One-time Donation
                </a>
            </div>
        </div>
        
        <div class="border-t border-gray-200 dark:border-gray-700 pt-4">
            <p class="text-center text-sm mb-4">Your support helps keep Reading Tracker ad-free and constantly improving.</p>
            <p class="text-center text-sm">Thank you for being part of this journey!</p>
        </div>
    </div>
</div>

    <script>
        // System state
        const appState = {
            // User settings
            settings: {
                dailyTarget: 10,
                streakCycle: 10,
                maxBuffer: 20,
                maxDailyBuffer: 5,
                maxBufferUses: 2,
                bufferDecayDays: 14,
                bufferDecayPercent: 50
            },
            
            // Current stats
            stats: {
                streakCounter: 0,
                freePass: 1,
                bufferPages: 0,
                weeklyBufferUses: 0,
                bufferDecayCountdown: 14,
                completedStreaks: 0,
                prestigeLevel: 0,
                totalPagesRead: 0,
                daysTracked: 0,
                longestStreak: 0,
                booksCompleted: 0,
                lastLogDate: null,
                readingHistory: [],
                dayStreak: {}
            },
            
            // Extended stats for new achievements
            extendedStats: {
                longestConsecutiveDays: 0,
                currentConsecutiveDays: 0,
                maxPagesInOneDay: 0,
                totalBufferPagesEarned: 0,
                freePassesUsed: 0,
                totalStreakCyclesCompleted: 0,
                readGenres: new Set(),
                lastCompletedStreak: null,
                streakCyclesWithoutFreePass: 0,
                appVersion: '1.1.0'
            },
            
            // Prestige bonuses
            bonuses: {
                maxDailyBufferBonus: 0,
                bufferCapacityBonus: 0,
                decayReductionBonus: 0,
                nonPrestigeActive: false
            },
            
            // Books
            books: [],
            
            // Achievements
            achievements: [
                {
                    id: 'first-day',
                    name: 'First Steps',
                    description: 'Log your first day of reading',
                    unlocked: false,
                    icon: 'üìñ',
                    category: 'basic'
                },
                {
                    id: 'first-streak',
                    name: 'Streak Starter',
                    description: 'Complete your first reading streak cycle',
                    unlocked: false,
                    icon: 'üî•',
                    category: 'streak'
                },
                {
                    id: 'buffer-master',
                    name: 'Buffer Master',
                    description: 'Fill your buffer to maximum capacity',
                    unlocked: false,
                    icon: 'üè¶',
                    category: 'basic'
                },
                {
                    id: 'book-finisher',
                    name: 'Book Finisher',
                    description: 'Complete your first book',
                    unlocked: false,
                    icon: 'üèÅ',
                    category: 'books'
                },
                {
                    id: 'prestige-1',
                    name: 'Prestigious Reader',
                    description: 'Reach Prestige Level 1',
                    unlocked: false,
                    icon: '‚≠ê',
                    category: 'prestige'
                },
                {
                    id: 'first-month',
                    name: 'Monthly Dedication',
                    description: 'Track your reading for 30 days',
                    unlocked: false,
                    icon: 'üìÖ',
                    category: 'basic'
                },
                {
                    id: 'pages-100',
                    name: 'Century Club',
                    description: 'Read a total of 100 pages',
                    unlocked: false,
                    icon: 'üíØ',
                    category: 'reading'
                },
                {
                    id: 'pages-1000',
                    name: 'Bookworm',
                    description: 'Read a total of 1,000 pages',
                    unlocked: false,
                    icon: 'üêõ',
                    category: 'reading'
                },
                // New achievements
                {
                    id: 'consecutive-50',
                    name: 'I Run, Therefore I Am',
                    description: 'Read for 50 consecutive days without missing a single day',
                    unlocked: false,
                    icon: 'üèÉ',
                    category: 'streak'
                },
                {
                    id: 'consecutive-100',
                    name: 'Marathon Mindset',
                    description: 'Read for 100 consecutive days without missing a single day',
                    unlocked: false,
                    icon: 'üèÉ‚Äç‚ôÄÔ∏è',
                    category: 'streak'
                },
                {
                    id: 'pages-day-50',
                    name: 'Speed Demon',
                    description: 'Read 50 pages in a single day',
                    unlocked: false,
                    icon: 'üëø',
                    category: 'reading'
                },
                {
                    id: 'books-50',
                    name: 'Completionist Crusader',
                    description: 'Complete 50 books',
                    unlocked: false,
                    icon: 'üõ°Ô∏è',
                    category: 'books'
                },
                {
                    id: 'genres-5',
                    name: 'Genre Explorer',
                    description: 'Read at least one book from 5 different genres',
                    unlocked: false,
                    icon: 'üß≠',
                    category: 'books'
                },
                {
                    id: 'flawless-streak',
                    name: 'Flawless Streak',
                    description: 'Complete 10 streak cycles without using a single free pass',
                    unlocked: false,
                    icon: '‚ú®',
                    category: 'streak'
                },
                {
                    id: 'pages-day-100',
                    name: 'Century Sprint',
                    description: 'Read 100 pages in a single day',
                    unlocked: false,
                    icon: 'üèéÔ∏è',
                    category: 'reading'
                },
                {
                    id: 'library-100',
                    name: 'Library Architect',
                    description: 'Add 100 books to your library',
                    unlocked: false,
                    icon: 'üìö',
                    category: 'books'
                },
                {
                    id: 'books-100',
                    name: 'Ultimate Bibliophile',
                    description: 'Complete 100 books',
                    unlocked: false,
                    icon: 'üìö',
                    category: 'books'
                },
                {
                    id: 'prestige-5',
                    name: 'Prestigious Adept I',
                    description: 'Reach Prestige Level 5',
                    unlocked: false,
                    icon: 'üåü',
                    category: 'prestige'
                },
                {
                    id: 'prestige-10',
                    name: 'Prestigious Adept II',
                    description: 'Reach Prestige Level 10',
                    unlocked: false,
                    icon: 'üåüüåü',
                    category: 'prestige'
                },
                {
                    id: 'prestige-20',
                    name: 'Prestigious Adept III',
                    description: 'Reach Prestige Level 20',
                    unlocked: false,
                    icon: 'üåüüåüüåü',
                    category: 'prestige'
                },
                {
                    id: 'prestige-50',
                    name: 'Prestigious Adept IV',
                    description: 'Reach Prestige Level 50',
                    unlocked: false,
                    icon: 'üåüüåüüåüüåü',
                    category: 'prestige'
                },
                // Extended gameplay achievements
                {
                    id: 'books-500',
                    name: 'Infinite Reader',
                    description: 'Complete 500 books',
                    unlocked: false,
                    icon: 'üîÑ',
                    category: 'endgame'
                },
                {
                    id: 'genres-10',
                    name: 'Genre Master',
                    description: 'Read at least one book from 10 different genres',
                    unlocked: false,
                    icon: 'üé≠',
                    category: 'endgame'
                },
                {
                    id: 'streak-cycles-50',
                    name: 'Streak Titan',
                    description: 'Complete 50 streak cycles',
                    unlocked: false,
                    icon: 'üëë',
                    category: 'endgame'
                },
                {
                    id: 'buffer-500',
                    name: 'Buffer King/Queen',
                    description: 'Bank 500 buffer pages in total',
                    unlocked: false,
                    icon: 'üëë',
                    category: 'endgame'
                },
                {
                    id: 'library-500',
                    name: 'Library Overlord',
                    description: 'Add 500 books to your library',
                    unlocked: false,
                    icon: 'üèõÔ∏è',
                    category: 'endgame'
                },
                {
                    id: 'consecutive-365',
                    name: 'The Eternal Reader',
                    description: 'Read for 365 consecutive days without missing a single day',
                    unlocked: false,
                    icon: '‚è≥',
                    category: 'endgame'
                },
                {
                    id: 'prestige-collector',
                    name: 'Prestige Collector',
                    description: 'Unlock all prestige-related achievements',
                    unlocked: false,
                    icon: 'üèÜ',
                    category: 'endgame'
                },
                {
                    id: 'consecutive-1000',
                    name: 'The Infinite Streak',
                    description: 'Maintain a streak of 1000 days without missing a single day',
                    unlocked: false,
                    icon: '‚àû',
                    category: 'endgame'
                },
                {
                    id: 'achievement-hunter',
                    name: 'Achievement Hunter',
                    description: 'Unlock all other achievements in the app',
                    unlocked: false,
                    icon: 'üéØ',
                    category: 'endgame'
                }
            ]
        };

        // DOM Elements
        const elements = {
            // Tab Navigation
            tabButtons: document.querySelectorAll('.tab-btn'),
            tabPanes: document.querySelectorAll('.tab-pane'),
            
            // Dashboard Elements
            targetPages: document.getElementById('target-pages'),
            progressText: document.getElementById('progress-text'),
            progressBar: document.getElementById('progress-bar'),
            pagesReadInput: document.getElementById('pages-read'),
            bookSelector: document.getElementById('book-selector'),
            logReadingBtn: document.getElementById('log-reading'),
            useBufferBtn: document.getElementById('use-buffer'),
            alreadyLogged: document.getElementById('already-logged'),
            logForm: document.getElementById('log-form'),
            
            // Stats Elements
            streakCounter: document.getElementById('streak-counter'),
            streakCycle: document.getElementById('streak-cycle'),
            freePass: document.getElementById('free-pass'),
            bufferPages: document.getElementById('buffer-pages'),
            maxBuffer: document.getElementById('max-buffer'),
            bufferUses: document.getElementById('buffer-uses'),
            maxBufferUses: document.getElementById('max-buffer-uses'),
            bufferDecay: document.getElementById('buffer-decay'),
            completedStreaks: document.getElementById('completed-streaks'),
            
            // New streak elements
            consecutiveDays: document.getElementById('consecutive-days'),
            longestConsecutiveDays: document.getElementById('longest-consecutive-days'),
            streakHeatmap: document.getElementById('streak-heatmap'),
            
            // Prestige Elements
            prestigeCard: document.getElementById('prestige-card'),
            prestigeBtn: document.getElementById('prestige-btn'),
            continueBtn: document.getElementById('continue-btn'),
            
            // Books Elements
            bookTitle: document.getElementById('book-title'),
            bookAuthor: document.getElementById('book-author'),
            bookGenre: document.getElementById('book-genre'),
            bookTotalPages: document.getElementById('book-total-pages'),
            bookCurrentPage: document.getElementById('book-current-page'),
            addBookBtn: document.getElementById('add-book-btn'),
            bookList: document.getElementById('book-list'),
            noBooksMessage: document.getElementById('no-books-message'),
            
            // Book filter buttons
            filterAll: document.getElementById('filter-all'),
            filterActive: document.getElementById('filter-active'),
            filterCompleted: document.getElementById('filter-completed'),
            sortBooks: document.getElementById('sort-books'),
            
            // Stats Tab Elements
            totalPagesRead: document.getElementById('total-pages-read'),
            daysTracked: document.getElementById('days-tracked'),
            avgPagesPerDay: document.getElementById('avg-pages-per-day'),
            longestStreak: document.getElementById('longest-streak'),
            booksCompleted: document.getElementById('books-completed'),
            prestigeLevel: document.getElementById('prestige-level'),
            readingChart: document.getElementById('reading-chart'),
            streakCalendar: document.getElementById('streak-calendar'),
            
            // New stats elements
            maxPagesDay: document.getElementById('max-pages-day'),
            totalBufferEarned: document.getElementById('total-buffer-earned'),
            uniqueGenres: document.getElementById('unique-genres'),
            freePassesUsed: document.getElementById('free-passes-used'),
            streakCyclesCompleted: document.getElementById('streak-cycles-completed'),
            avgCompletionTime: document.getElementById('avg-completion-time'),
            
            // History filter elements
            historyPeriod: document.getElementById('history-period'),
            historyBook: document.getElementById('history-book'),
            historyGrouping: document.getElementById('history-grouping'),
            
            // Weekly pattern chart
            weeklyPatternChart: document.getElementById('weekly-pattern-chart'),
            
            // Reading timeline
            readingTimeline: document.getElementById('reading-timeline'),
            
            // Genre chart
            genreChart: document.getElementById('genre-chart'),
            genreLegend: document.getElementById('genre-legend'),
            
            // Achievements Elements
            achievementsList: document.getElementById('achievements-list'),
            achievementsCount: document.getElementById('achievements-count'),
            achievementCategories: document.querySelectorAll('.achievement-category'),
            searchAchievements: document.getElementById('search-achievements'),
            filterAchievements: document.getElementById('filter-achievements'),
            
            // Recent achievements
            recentAchievements: document.getElementById('recent-achievements'),
            noAchievements: document.getElementById('no-achievements'),
            
            // Insights tab
            insightsContainer: document.getElementById('insights-container'),
            noInsights: document.getElementById('no-insights'),
            
            // Milestones
            pagesMilestoneText: document.getElementById('pages-milestone-text'),
            pagesMilestoneBar: document.getElementById('pages-milestone-bar'),
            booksMilestoneText: document.getElementById('books-milestone-text'),
            booksMilestoneBar: document.getElementById('books-milestone-bar'),
            streakMilestoneText: document.getElementById('streak-milestone-text'),
            streakMilestoneBar: document.getElementById('streak-milestone-bar'),
            prestigeMilestoneText: document.getElementById('prestige-milestone-text'),
            prestigeMilestoneBar: document.getElementById('prestige-milestone-bar'),
            
            // Next achievements
            nextAchievements: document.getElementById('next-achievements'),
            
            // Settings tab
            settingDailyTarget: document.getElementById('setting-daily-target'),
            updateTarget: document.getElementById('update-target'),
            currentDailyTarget: document.getElementById('current-daily-target'),
            
            // Data management
            exportData: document.getElementById('export-data'),
            importData: document.getElementById('import-data'),
            resetData: document.getElementById('reset-data'),
            importContainer: document.getElementById('import-container'),
            importDataText: document.getElementById('import-data-text'),
            confirmImport: document.getElementById('confirm-import'),
            cancelImport: document.getElementById('cancel-import'),
            
            // App info
            appVersion: document.getElementById('app-version'),
            footerVersion: document.getElementById('footer-version'),
            
            // Export modal
            exportModal: document.getElementById('export-modal'),
            closeExportModal: document.getElementById('close-export-modal'),
            exportDataText: document.getElementById('export-data-text'),
            copyExportData: document.getElementById('copy-export-data'),
            doneExport: document.getElementById('done-export'),
            
            // Confirmation modal
            confirmationModal: document.getElementById('confirmation-modal'),
            confirmationTitle: document.getElementById('confirmation-title'),
            confirmationMessage: document.getElementById('confirmation-message'),
            confirmAction: document.getElementById('confirm-action'),
            cancelAction: document.getElementById('cancel-action')
        };

        // Initialize the application
        function initializeApp() {
    migrateDataIfNeeded();
    loadAppState();

    // Check if daily target is not set or is invalid
    if (!appState.settings.dailyTarget || appState.settings.dailyTarget < 5) {
        let dailyTarget = parseInt(prompt('Set your daily reading target (minimum 5, recommended 10):', 10));

        // Validate input
        while (isNaN(dailyTarget) || dailyTarget < 5) {
            dailyTarget = parseInt(prompt('Invalid input. Please enter a number greater than or equal to 5:', 10));
        }

        // Set the daily target
        appState.settings.dailyTarget = dailyTarget;
        saveAppState();
    }

    setupEventListeners();
    renderUI();
    checkDailyLogin();
    renderAchievements();
    renderBooks();
    renderStats();
    renderInsights();
    renderMilestones();
    renderNextAchievements();
    renderRecentAchievements();
    checkPrestigeEligibility();
}

        // Migrate data from older versions if needed
        function migrateDataIfNeeded() {
            const savedState = localStorage.getItem('readingTrackerState');
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                
                // Check if we need to migrate from version 1.0.0 to 1.1.0
                if (!parsedState.extendedStats || !parsedState.extendedStats.appVersion) {
                    console.log('Migrating data from version 1.0.0 to 1.1.0');
                    
                    // Create extended stats
                    parsedState.extendedStats = {
                        longestConsecutiveDays: calculateConsecutiveDays(parsedState.stats.dayStreak),
                        currentConsecutiveDays: calculateCurrentConsecutiveDays(parsedState.stats.dayStreak),
                        maxPagesInOneDay: calculateMaxPagesInOneDay(parsedState.stats.readingHistory),
                        totalBufferPagesEarned: 0, // Start tracking from now
                        freePassesUsed: 0, // Start tracking from now
                        totalStreakCyclesCompleted: parsedState.stats.completedStreaks,
                        readGenres: new Set(extractGenres(parsedState.books)),
                        lastCompletedStreak: null,
                        streakCyclesWithoutFreePass: 0,
                        appVersion: '1.1.0'
                    };
                    
                    // Add categories to achievements
                    parsedState.achievements.forEach(achievement => {
                        if (!achievement.category) {
                            if (achievement.id.includes('prestige')) {
                                achievement.category = 'prestige';
                            } else if (achievement.id.includes('streak') || achievement.id === 'first-streak') {
                                achievement.category = 'streak';
                            } else if (achievement.id.includes('book') || achievement.id === 'book-finisher') {
                                achievement.category = 'books';
                            } else if (achievement.id.includes('pages') || achievement.id.includes('buffer')) {
                                achievement.category = 'reading';
                            } else {
                                achievement.category = 'basic';
                            }
                        }
                    });
                    
                    // Save migrated state
                    localStorage.setItem('readingTrackerState', JSON.stringify(parsedState));
                }
            }
        }

        // Helper for migration - Calculate consecutive days
        function calculateConsecutiveDays(dayStreak) {
            if (!dayStreak || Object.keys(dayStreak).length === 0) return 0;
            
            const dates = Object.keys(dayStreak)
                .filter(date => dayStreak[date])
                .map(date => new Date(date).getTime())
                .sort((a, b) => a - b);
            
            if (dates.length === 0) return 0;
            
            let maxConsecutive = 1;
            let currentConsecutive = 1;
            
            for (let i = 1; i < dates.length; i++) {
                const prevDate = new Date(dates[i - 1]);
                const currDate = new Date(dates[i]);
                
                const diffDays = Math.round((currDate - prevDate) / (1000 * 60 * 60 * 24));
                
                if (diffDays === 1) {
                    currentConsecutive++;
                } else {
                    if (currentConsecutive > maxConsecutive) {
                        maxConsecutive = currentConsecutive;
                    }
                    currentConsecutive = 1;
                }
            }
            
            return Math.max(maxConsecutive, currentConsecutive);
        }

        // Helper for migration - Calculate current consecutive days
        function calculateCurrentConsecutiveDays(dayStreak) {
            if (!dayStreak || Object.keys(dayStreak).length === 0) return 0;
            
            const dates = Object.keys(dayStreak)
                .filter(date => dayStreak[date])
                .map(date => new Date(date).getTime())
                .sort((a, b) => b - a); // Sort descending for most recent first
            
            if (dates.length === 0) return 0;
            
            const today = new Date().setHours(0, 0, 0, 0);
            const mostRecentDate = new Date(dates[0]).setHours(0, 0, 0, 0);
            
            // If most recent date is not today or yesterday, streak is broken
            const diffDays = Math.round((today - mostRecentDate) / (1000 * 60 * 60 * 24));
            if (diffDays > 1) return 0;
            
            let consecutiveDays = 1;
            for (let i = 1; i < dates.length; i++) {
                const prevDate = new Date(dates[i - 1]).setHours(0, 0, 0, 0);
                const currDate = new Date(dates[i]).setHours(0, 0, 0, 0);
                
                const diffDays = Math.round((prevDate - currDate) / (1000 * 60 * 60 * 24));
                
                if (diffDays === 1) {
                    consecutiveDays++;
                } else {
                    break;
                }
            }
            
            return consecutiveDays;
        }

        // Helper for migration - Calculate max pages in one day
        function calculateMaxPagesInOneDay(readingHistory) {
            if (!readingHistory || readingHistory.length === 0) return 0;
            
            const pagesByDate = {};
            
            readingHistory.forEach(entry => {
                if (!pagesByDate[entry.date]) {
                    pagesByDate[entry.date] = 0;
                }
                pagesByDate[entry.date] += entry.pages;
            });
            
            return Math.max(...Object.values(pagesByDate));
        }

        // Helper for migration - Extract unique genres from books
        function extractGenres(books) {
            if (!books || books.length === 0) return [];
            
            return [...new Set(books
                .filter(book => book.genre && book.genre.trim() !== '')
                .map(book => book.genre.trim())
            )];
        }

        // Load app state from localStorage
        function loadAppState() {
            const savedState = localStorage.getItem('readingTrackerState');
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                
                // Restore Set objects which get serialized as arrays
                if (parsedState.extendedStats && Array.isArray(parsedState.extendedStats.readGenres)) {
                    parsedState.extendedStats.readGenres = new Set(parsedState.extendedStats.readGenres);
                }
                
                Object.assign(appState, parsedState);
            }
            
            // Initialize settings elements
            if (elements.settingDailyTarget) {
                elements.settingDailyTarget.value = appState.settings.dailyTarget;
                elements.currentDailyTarget.textContent = appState.settings.dailyTarget;
            }
            
            // Set version information
            if (elements.appVersion) elements.appVersion.textContent = appState.extendedStats.appVersion;
            if (elements.footerVersion) elements.footerVersion.textContent = appState.extendedStats.appVersion;
        }

        // Save app state to localStorage
        function saveAppState() {
            // Convert Sets to Arrays for JSON serialization
            const stateToSave = JSON.parse(JSON.stringify(appState));
            if (stateToSave.extendedStats && stateToSave.extendedStats.readGenres instanceof Set) {
                stateToSave.extendedStats.readGenres = [...appState.extendedStats.readGenres];
            }
            
            localStorage.setItem('readingTrackerState', JSON.stringify(stateToSave));
        }

        // Set up event listeners
        function setupEventListeners() {
            // Tab navigation
            elements.tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    elements.tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    const tabId = button.getAttribute('data-tab');
                    elements.tabPanes.forEach(pane => pane.classList.add('hidden'));
                    document.getElementById(tabId).classList.remove('hidden');
                    
                    if (tabId === 'stats') {
                        renderStats();
                    } else if (tabId === 'achievements') {
                        renderAchievements();
                    } else if (tabId === 'books') {
                        renderBooks();
                        renderGenreChart();
                    } else if (tabId === 'insights') {
                        renderInsights();
                        renderMilestones();
                        renderNextAchievements();
                    }
                });
            });
            
            // Log reading button
            elements.logReadingBtn.addEventListener('click', logReading);
            
            // Use buffer button
            elements.useBufferBtn.addEventListener('click', useBuffer);
            
            // Add book button
            elements.addBookBtn.addEventListener('click', addBook);
            
            // Prestige button
            elements.prestigeBtn.addEventListener('click', prestige);
            
            // Continue button
            elements.continueBtn.addEventListener('click', continueWithoutPrestige);
            
            // Book filters
            if (elements.filterAll) {
                elements.filterAll.addEventListener('click', () => filterBooks('all'));
                elements.filterActive.addEventListener('click', () => filterBooks('active'));
                elements.filterCompleted.addEventListener('click', () => filterBooks('completed'));
                elements.sortBooks.addEventListener('change', () => sortBooks(elements.sortBooks.value));
            }
            
            // History filters
            if (elements.historyPeriod) {
                elements.historyPeriod.addEventListener('change', renderReadingChart);
                elements.historyBook.addEventListener('change', renderReadingChart);
                elements.historyGrouping.addEventListener('change', renderReadingChart);
            }
            
            // Achievement filters
            if (elements.achievementCategories) {
                elements.achievementCategories.forEach(button => {
                    button.addEventListener('click', () => {
                        elements.achievementCategories.forEach(btn => btn.classList.remove('active', 'bg-primary', 'text-white'));
                        button.classList.add('active', 'bg-primary', 'text-white');
                        filterAchievementsByCategory(button.getAttribute('data-category'));
                    });
                });
                
                elements.searchAchievements.addEventListener('input', filterAchievementsBySearch);
                elements.filterAchievements.addEventListener('change', filterAchievementsByStatus);
            }
            
            // Settings tab
            if (elements.updateTarget) {
                elements.updateTarget.addEventListener('click', updateDailyTarget);
                
                // Data management
		// Export data button
    		elements.exportData.addEventListener('click', showExportModal);

    		// Copy to clipboard button
    		elements.copyExportData.addEventListener('click', copyExportDataToClipboard);

    		// Close export modal button
    		elements.closeExportModal.addEventListener('click', hideExportModal);

    		// Done export button
 	        elements.doneExport.addEventListener('click', hideExportModal);
                
		elements.importData.addEventListener('click', showImportPanel);
                elements.resetData.addEventListener('click', confirmResetData);
                elements.confirmImport.addEventListener('click', importUserData);
                elements.cancelImport.addEventListener('click', hideImportPanel);
                
                // Confirmation modal
                elements.cancelAction.addEventListener('click', hideConfirmationModal);
            }
        }

        // Update UI with current state
        function renderUI() {
    // Update dashboard
    elements.targetPages.textContent = appState.settings.dailyTarget;
    elements.progressText.textContent = `0/${appState.settings.dailyTarget}`;
    elements.progressBar.style.width = '0%';

// Get modal elements
const supportModal = document.getElementById('supportModal');
const closeSupportModal = document.getElementById('closeSupportModal');
const supportButtons = document.querySelectorAll('#supportButton');

// Show modal when any support button is clicked
supportButtons.forEach(button => {
    button.addEventListener('click', () => {
        supportModal.classList.remove('hidden');
    });
});

// Hide modal when close button is clicked
closeSupportModal.addEventListener('click', () => {
    supportModal.classList.add('hidden');
});

// Hide modal when clicking outside the modal
window.addEventListener('click', (event) => {
    if (event.target === supportModal) {
        supportModal.classList.add('hidden');
    }
});

    // Update Max Daily Buffer
    const maxDailyBuffer = document.getElementById('max-daily-buffer');
    if (maxDailyBuffer) {
        maxDailyBuffer.textContent = appState.settings.maxDailyBuffer;
    }

    // Update the "Daily Target" value in the Dashboard
    const dailyTargetValue = document.getElementById('daily-target-value');
    if (dailyTargetValue) {
        dailyTargetValue.textContent = appState.settings.dailyTarget;
    }

    // Update stats
    elements.streakCounter.textContent = appState.stats.streakCounter;
    elements.streakCycle.textContent = appState.settings.streakCycle;
    elements.freePass.textContent = appState.stats.freePass;
    elements.bufferPages.textContent = appState.stats.bufferPages;
    elements.maxBuffer.textContent = appState.settings.maxBuffer + appState.bonuses.bufferCapacityBonus;
    elements.bufferUses.textContent = appState.stats.weeklyBufferUses;
    elements.maxBufferUses.textContent = appState.bonuses.nonPrestigeActive ? '3' : appState.settings.maxBufferUses;
    elements.bufferDecay.textContent = appState.stats.bufferDecayCountdown;
    elements.completedStreaks.textContent = appState.stats.completedStreaks;

    // Update consecutive days
    if (elements.consecutiveDays) {
        elements.consecutiveDays.textContent = appState.extendedStats.currentConsecutiveDays;
        elements.longestConsecutiveDays.textContent = appState.extendedStats.longestConsecutiveDays;
        renderStreakHeatmap();
    }

    // Update book selector
    updateBookSelector();

    // Check if already logged today
    checkDailyLogStatus();

    // Update use buffer button state
    updateBufferButtonState();
}

        // Render streak heatmap
        function renderStreakHeatmap() {
            if (!elements.streakHeatmap) return;
            
            elements.streakHeatmap.innerHTML = '';
            
            // Get last 30 days
            const today = new Date();
            const days = [];
            
            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                days.push(date);
            }
            
            // Create heatmap cells
            days.forEach(date => {
                const dateStr = date.toDateString();
                const isToday = dateStr === today.toDateString();
                const hasReading = appState.stats.dayStreak[dateStr];
                
                const cell = document.createElement('div');
                cell.className = 'w-6 h-6 rounded-sm flex items-center justify-center text-xs';
                
                if (hasReading) {
                    cell.className += ' bg-success text-white';
                } else if (isToday) {
                    cell.className += ' bg-primary bg-opacity-20 border border-primary';
                } else if (date > today) {
                    cell.className += ' bg-gray-100 dark:bg-gray-800 text-gray-400';
                } else {
                    cell.className += ' bg-red-100 dark:bg-red-900 dark:bg-opacity-30';
                }
                
                cell.textContent = date.getDate();
                cell.title = dateStr;
                
                elements.streakHeatmap.appendChild(cell);
            });
        }

        // Check if already logged reading today
        function checkDailyLogStatus() {
            const today = new Date().toDateString();
            if (appState.stats.lastLogDate === today) {
                elements.alreadyLogged.classList.remove('hidden');
                elements.logForm.classList.add('hidden');
            } else {
                elements.alreadyLogged.classList.add('hidden');
                elements.logForm.classList.remove('hidden');
            }
        }

        // Update buffer button state
        function updateBufferButtonState() {
            const canUseBuffer = 
                appState.stats.bufferPages > 0 && 
                appState.stats.weeklyBufferUses < (appState.bonuses.nonPrestigeActive ? 3 : appState.settings.maxBufferUses) &&
                appState.stats.lastLogDate !== new Date().toDateString();
                
            elements.useBufferBtn.disabled = !canUseBuffer;
            
            if (canUseBuffer) {
                elements.useBufferBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                elements.useBufferBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // Check for daily login
function checkDailyLogin() {
    const today = new Date().toDateString();
    const lastLogin = localStorage.getItem('readingTrackerLastLogin');

    // Check if this is a new day
    if (lastLogin !== today) {
        // Decrease buffer decay countdown
        if (appState.stats.bufferDecayCountdown > 0) {
            appState.stats.bufferDecayCountdown--;
        }

        // Check if buffer decay countdown has reached 0
        if (appState.stats.bufferDecayCountdown === 0) {
            // Calculate decay amount
            const decayPercent = appState.settings.bufferDecayPercent - appState.bonuses.decayReductionBonus;
            const decayAmount = Math.ceil(appState.stats.bufferPages * (decayPercent / 100));

            // Apply decay to buffer pages
            appState.stats.bufferPages = Math.max(0, appState.stats.bufferPages - decayAmount);

            // Reset buffer decay countdown
            appState.stats.bufferDecayCountdown = appState.bonuses.nonPrestigeActive ? 20 : appState.settings.bufferDecayDays;
        }

        // Check and update consecutive days
        checkConsecutiveDays();

        // Save the current date as the last login date
        localStorage.setItem('readingTrackerLastLogin', today);

        // Save the updated state and refresh the UI
        saveAppState();
        renderUI();
    }
}

        // Check and update consecutive days
        function checkConsecutiveDays() {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            
            const yesterdayStr = yesterday.toDateString();
            
            // If no reading yesterday, reset consecutive days unless today already has reading
            if (!appState.stats.dayStreak[yesterdayStr] && !appState.stats.dayStreak[today.toDateString()]) {
                appState.extendedStats.currentConsecutiveDays = 0;
            }
        }

        // Log reading
        function logReading() {
            const pagesRead = parseInt(elements.pagesReadInput.value) || 0;
            const selectedBookId = elements.bookSelector.value;
            
            if (pagesRead <= 0) {
                showNotification('Please enter a valid number of pages', 'error');
                return;
            }
            
            if (!selectedBookId) {
                showNotification('Please select a book', 'error');
                return;
            }
            
            const today = new Date().toDateString();
            if (appState.stats.lastLogDate === today) {
                showNotification('You\'ve already logged your reading for today', 'error');
                return;
            }
            
            // Update book progress
            const bookIndex = appState.books.findIndex(book => book.id === selectedBookId);
            if (bookIndex !== -1) {
                const book = appState.books[bookIndex];
                const newPage = book.currentPage + pagesRead;
                const wasCompleted = book.completed;
                
                // Check if book completed
                if (newPage >= book.totalPages) {
                    appState.books[bookIndex].currentPage = book.totalPages;
                    appState.books[bookIndex].completed = true;
                    appState.books[bookIndex].dateCompleted = new Date().toISOString();
                    
                    if (!wasCompleted) {
                        appState.stats.booksCompleted++;
                        
                        // Add genre to read genres
                        if (book.genre && book.genre.trim() !== '') {
                            appState.extendedStats.readGenres.add(book.genre.trim());
                        }
                        
                        // Unlock achievement
                        unlockAchievement('book-finisher');
                        
                        // Check book count achievements
                        checkBookCountAchievements();
                        
                        // Check genre count achievements
                        checkGenreCountAchievements();
                        
                        showNotification(`Congratulations! You've completed "${book.title}"!`, 'success');
                    }
                } else {
                    appState.books[bookIndex].currentPage = newPage;
                }
            }
            
            // Update stats
            appState.stats.totalPagesRead += pagesRead;
            appState.stats.daysTracked++;
            appState.stats.lastLogDate = today;
            
            // Update max pages in one day
            if (pagesRead > appState.extendedStats.maxPagesInOneDay) {
                appState.extendedStats.maxPagesInOneDay = pagesRead;
                
                // Check page count achievements
                checkPagesInOneDayAchievements();
            }
            
            // Add to reading history
            appState.stats.readingHistory.push({
                date: today,
                pages: pagesRead,
                bookId: selectedBookId
            });
            
            // Update day streak
            appState.stats.dayStreak[today] = true;
            
            // Update consecutive days
            appState.extendedStats.currentConsecutiveDays++;
            if (appState.extendedStats.currentConsecutiveDays > appState.extendedStats.longestConsecutiveDays) {
                appState.extendedStats.longestConsecutiveDays = appState.extendedStats.currentConsecutiveDays;
            }
            
            // Check consecutive days achievements
            checkConsecutiveDaysAchievements();
            
            // Check for achievements
            checkPagesAchievements();
            
            if (appState.stats.daysTracked === 1) {
                unlockAchievement('first-day');
            }
            
            if (appState.stats.daysTracked >= 30) {
                unlockAchievement('first-month');
            }
            
            // Process progress
            processReadingProgress(pagesRead);

	    // Update buffer decay countdown
    	    checkDailyLogin();
            
            // Save state and update UI
            saveAppState();
            renderUI();
            renderStats();
            renderBooks();
            renderGenreChart();
            renderInsights();
            renderMilestones();
            renderNextAchievements();
            renderRecentAchievements();
            
            // Reset input
            elements.pagesReadInput.value = '';
            
            showNotification('Reading logged successfully!', 'success');
        }

        // Process reading progress
        function processReadingProgress(pagesRead) {
            const dailyTarget = appState.settings.dailyTarget;
            
            // Check if target met
            if (pagesRead >= dailyTarget) {
                // Increment streak counter
                appState.stats.streakCounter++;
                
                // Update longest streak
                if (appState.stats.streakCounter > appState.stats.longestStreak) {
                    appState.stats.longestStreak = appState.stats.streakCounter;
                }
                
                // Check if streak cycle completed
                if (appState.stats.streakCounter >= appState.settings.streakCycle) {
                    appState.stats.completedStreaks++;
                    appState.extendedStats.totalStreakCyclesCompleted++;
                    appState.stats.streakCounter = 0;
                    
                    // Check if streak was completed without using a free pass
                    if (appState.stats.freePass === 1) {
                        appState.extendedStats.streakCyclesWithoutFreePass++;
                        
                        // Check for flawless streak achievement
                        if (appState.extendedStats.streakCyclesWithoutFreePass >= 10) {
                            unlockAchievement('flawless-streak');
                        }
                    }
                    
                    // Replenish free pass
                    appState.stats.freePass = 1;
                    
                    // Increase daily target
                    appState.settings.dailyTarget++;
                    
                    // Update last completed streak
                    appState.extendedStats.lastCompletedStreak = new Date().toISOString();
                    
                    showNotification('Streak cycle completed! Daily target increased by 1 page.', 'success');
                    
                    if (appState.stats.completedStreaks === 1) {
                        unlockAchievement('first-streak');
                    }
                    
                    // Check for streak cycles achievement
                    if (appState.extendedStats.totalStreakCyclesCompleted >= 50) {
                        unlockAchievement('streak-cycles-50');
                    }
                    
                    // Check for prestige eligibility
                    checkPrestigeEligibility();
                }
                
                // Bank extra pages
                const extraPages = pagesRead - dailyTarget;
                const maxDailyBuffer = appState.settings.maxDailyBuffer + appState.bonuses.maxDailyBufferBonus;
                const pagesToBank = Math.min(extraPages, maxDailyBuffer);
                
                if (pagesToBank > 0) {
                    const maxBuffer = appState.settings.maxBuffer + appState.bonuses.bufferCapacityBonus;
                    const oldBufferPages = appState.stats.bufferPages;
                    appState.stats.bufferPages = Math.min(appState.stats.bufferPages + pagesToBank, maxBuffer);
                    
                    // Track total buffer pages earned
                    appState.extendedStats.totalBufferPagesEarned += (appState.stats.bufferPages - oldBufferPages);
                    
                    // Check buffer king/queen achievement
                    if (appState.extendedStats.totalBufferPagesEarned >= 500) {
                        unlockAchievement('buffer-500');
                    }
                    
                    // Check buffer master achievement
                    if (appState.stats.bufferPages === maxBuffer) {
                        unlockAchievement('buffer-master');
                    }
                }
            } else {
                // Target not met
                showNotification('Daily target not met. Your streak has been reset.', 'error');
                appState.stats.streakCounter = 0;
            }
        }

        // Use buffer
        function useBuffer() {
            if (appState.stats.bufferPages <= 0) {
                showNotification('No buffer pages available', 'error');
                return;
            }
            
            if (appState.stats.weeklyBufferUses >= (appState.bonuses.nonPrestigeActive ? 3 : appState.settings.maxBufferUses)) {
                showNotification('Weekly buffer uses exhausted', 'error');
                return;
            }
            
            const today = new Date().toDateString();
            if (appState.stats.lastLogDate === today) {
                showNotification('You\'ve already logged your reading for today', 'error');
                return;
            }
            
            // Use buffer
            const pagesNeeded = appState.settings.dailyTarget;
            const pagesUsed = Math.min(pagesNeeded, appState.stats.bufferPages);
            
            appState.stats.bufferPages -= pagesUsed;
            appState.stats.weeklyBufferUses++;
            appState.stats.lastLogDate = today;
            
            // Update day streak
            appState.stats.dayStreak[today] = true;
            
            // Update consecutive days
            appState.extendedStats.currentConsecutiveDays++;
            if (appState.extendedStats.currentConsecutiveDays > appState.extendedStats.longestConsecutiveDays) {
                appState.extendedStats.longestConsecutiveDays = appState.extendedStats.currentConsecutiveDays;
            }
            
            // Check consecutive days achievements
            checkConsecutiveDaysAchievements();
            
            // Add to reading history with buffer usage
            appState.stats.readingHistory.push({
                date: today,
                pages: pagesUsed,
                buffer: true
            });
            
            // Update total pages read
            appState.stats.totalPagesRead += pagesUsed;
            
            // Check pages achievements
            checkPagesAchievements();
            
            // Increment streak counter
            appState.stats.streakCounter++;
            
            // Update longest streak
            if (appState.stats.streakCounter > appState.stats.longestStreak) {
                appState.stats.longestStreak = appState.stats.streakCounter;
            }
            
            // Check if streak cycle completed
            if (appState.stats.streakCounter >= appState.settings.streakCycle) {
                appState.stats.completedStreaks++;
                appState.extendedStats.totalStreakCyclesCompleted++;
                appState.stats.streakCounter = 0;
                appState.stats.freePass = 1;
                appState.settings.dailyTarget++;
                
                // Update last completed streak
                appState.extendedStats.lastCompletedStreak = new Date().toISOString();
                
                showNotification('Streak cycle completed! Daily target increased by 1 page.', 'success');
                
                if (appState.stats.completedStreaks === 1) {
                    unlockAchievement('first-streak');
                }
                
                // Check for streak cycles achievement
                if (appState.extendedStats.totalStreakCyclesCompleted >= 50) {
                    unlockAchievement('streak-cycles-50');
                }
                
                // Check for prestige eligibility
                checkPrestigeEligibility();
            }
            
            // Save state and update UI
            saveAppState();
            renderUI();
            renderStats();
            renderInsights();
            renderMilestones();
            renderRecentAchievements();
            
            showNotification(`Used ${pagesUsed} buffer pages successfully!`, 'success');
        }

        // Add a new book
        function addBook() {
            const title = elements.bookTitle.value.trim();
            const author = elements.bookAuthor.value.trim();
            const genre = elements.bookGenre.value.trim();
            const totalPages = parseInt(elements.bookTotalPages.value) || 0;
            const currentPage = parseInt(elements.bookCurrentPage.value) || 0;
            
            if (!title) {
                showNotification('Please enter a book title', 'error');
                return;
            }
            
            if (totalPages <= 0) {
                showNotification('Please enter a valid number of total pages', 'error');
                return;
            }
            
            if (currentPage < 0 || currentPage > totalPages) {
                showNotification('Current page must be between 0 and total pages', 'error');
                return;
            }
            
            // Create new book
            const newBook = {
                id: 'book_' + Date.now(),
                title,
                author,
                genre,
                totalPages,
                currentPage,
                completed: currentPage >= totalPages,
                dateAdded: new Date().toISOString(),
                dateCompleted: currentPage >= totalPages ? new Date().toISOString() : null
            };
            
            // Add to books array
            appState.books.push(newBook);
            
            // Check for library size achievements
            if (appState.books.length >= 100) {
                unlockAchievement('library-100');
            }
            
            if (appState.books.length >= 500) {
                unlockAchievement('library-500');
            }
            
            // If book is already completed, increment counter and update genre stats
            if (newBook.completed) {
                appState.stats.booksCompleted++;
                
                // Add genre to read genres if it exists
                if (genre && genre.trim() !== '') {
                    appState.extendedStats.readGenres.add(genre.trim());
                }
                
                // Check for book finisher achievement
                unlockAchievement('book-finisher');
                
                // Check book count achievements
                checkBookCountAchievements();
                
                // Check genre count achievements
                checkGenreCountAchievements();
            }
            
            // Save state and update UI
            saveAppState();
            renderBooks();
            renderGenreChart();
            updateBookSelector();
            renderStats();
            renderInsights();
            renderMilestones();
            renderNextAchievements();
            
            // Reset form
            elements.bookTitle.value = '';
            elements.bookAuthor.value = '';
            elements.bookGenre.value = '';
            elements.bookTotalPages.value = '';
            elements.bookCurrentPage.value = '';
            
            showNotification('Book added successfully!', 'success');
        }

        // Render books
        function renderBooks() {
            // Update book list
            if (appState.books.length === 0) {
                elements.noBooksMessage.classList.remove('hidden');
                elements.bookList.innerHTML = '';
                return;
            }
            
            // Get current filter
            const activeFilter = document.querySelector('.filter-btn.active');
            const filterValue = activeFilter ? activeFilter.id.replace('filter-', '') : 'all';
            
            // Get current sort
            const sortValue = elements.sortBooks ? elements.sortBooks.value : 'recent';
            
            // Filter and sort books
            let filteredBooks = [...appState.books];
            
            if (filterValue === 'active') {
                filteredBooks = filteredBooks.filter(book => !book.completed);
            } else if (filterValue === 'completed') {
                filteredBooks = filteredBooks.filter(book => book.completed);
            }
            
            // Sort books
            if (sortValue === 'title') {
                filteredBooks.sort((a, b) => a.title.localeCompare(b.title));
            } else if (sortValue === 'progress') {
                filteredBooks.sort((a, b) => {
                    const progressA = a.totalPages > 0 ? a.currentPage / a.totalPages : 0;
                    const progressB = b.totalPages > 0 ? b.currentPage / b.totalPages : 0;
                    return progressB - progressA; // Descending
                });
            } else if (sortValue === 'pages') {
                filteredBooks.sort((a, b) => b.totalPages - a.totalPages); // Descending
            } else {
                // Default to recent (dateAdded)
                filteredBooks.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
            }
            
            elements.noBooksMessage.classList.add('hidden');
            elements.bookList.innerHTML = '';
            
            filteredBooks.forEach(book => {
                const progress = book.totalPages > 0 ? Math.round((book.currentPage / book.totalPages) * 100) : 0;
                
                // Calculate estimated completion date (for active books)
                let estimatedCompletion = '';
                if (!book.completed && book.currentPage > 0) {
                    const pagesLeft = book.totalPages - book.currentPage;
                    
                    // Get average pages per day based on this book's history
                    const bookReadingHistory = appState.stats.readingHistory.filter(entry => entry.bookId === book.id);
                    let avgPagesPerDay = 0;
                    
                    if (bookReadingHistory.length > 0) {
                        const totalBookPages = bookReadingHistory.reduce((sum, entry) => sum + entry.pages, 0);
                        avgPagesPerDay = totalBookPages / bookReadingHistory.length;
                    } else {
                        // Use overall average if no history for this book
                        avgPagesPerDay = appState.stats.daysTracked > 0 ? 
                            appState.stats.totalPagesRead / appState.stats.daysTracked : 
                            appState.settings.dailyTarget;
                    }
                    
                    // Ensure we don't divide by zero
                    if (avgPagesPerDay > 0) {
                        const daysToComplete = Math.ceil(pagesLeft / avgPagesPerDay);
                        
                        if (daysToComplete <= 1) {
                            estimatedCompletion = '~1 day';
                        } else if (daysToComplete < 7) {
                            estimatedCompletion = `~${daysToComplete} days`;
                        } else if (daysToComplete < 30) {
                            estimatedCompletion = `~${Math.ceil(daysToComplete / 7)} weeks`;
                        } else {
                            estimatedCompletion = `~${Math.ceil(daysToComplete / 30)} months`;
                        }
                    }
                }
                
                const bookEl = document.createElement('div');
                bookEl.className = 'p-4 bg-white dark:bg-dark-background rounded-lg shadow-sm border border-light-border dark:border-dark-border';
                
                // Dynamic progress bar color
                let progressColor = 'bg-primary';
                if (progress >= 75) {
                    progressColor = 'bg-success';
                } else if (progress >= 50) {
                    progressColor = 'bg-blue-500';
                } else if (progress >= 25) {
                    progressColor = 'bg-yellow-500';
                }
                
                bookEl.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <div>
                            <h3 class="font-bold text-lg">${book.title}</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-400">
                                ${book.author || 'Unknown Author'}
                                ${book.genre ? ` ‚Ä¢ ${book.genre}` : ''}
                            </p>
                        </div>
                        <span class="text-xs px-2 py-1 rounded-full ${book.completed ? 'bg-success text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}">${book.completed ? 'Completed' : `${progress}%`}</span>
                    </div>
                    
                    <div class="mb-2">
                        <div class="flex justify-between text-xs mb-1">
                            <span>${book.currentPage} / ${book.totalPages} pages</span>
                            ${estimatedCompletion ? `<span>Est. completion: ${estimatedCompletion}</span>` : ''}
                        </div>
                        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                            <div class="${progressColor} rounded-full h-2" style="width: ${progress}%"></div>
                        </div>
                    </div>
                    
                    <div class="mt-2 flex justify-between items-center">
                        <div class="text-xs text-gray-500 dark:text-gray-400">
                            ${book.completed ? 
                                `Completed: ${new Date(book.dateCompleted).toLocaleDateString()}` : 
                                `Added: ${new Date(book.dateAdded).toLocaleDateString()}`
                            }
                        </div>
                        <div class="flex space-x-2">
                            <button class="text-xs px-2 py-1 bg-primary hover:bg-secondary text-white rounded-md" onclick="editBook('${book.id}')">Edit</button>
                            <button class="text-xs px-2 py-1 bg-danger hover:bg-red-500 text-white rounded-md" onclick="deleteBook('${book.id}')">Delete</button>
                        </div>
                    </div>
                `;
                
                elements.bookList.appendChild(bookEl);
            });
        }

        // Filter books by status
        function filterBooks(filter) {
            const buttons = [elements.filterAll, elements.filterActive, elements.filterCompleted];
            
            buttons.forEach(btn => {
                btn.classList.remove('active', 'bg-primary', 'text-white');
                btn.classList.add('bg-gray-200', 'dark:bg-gray-700');
            });
            
            document.getElementById(`filter-${filter}`).classList.add('active', 'bg-primary', 'text-white');
            document.getElementById(`filter-${filter}`).classList.remove('bg-gray-200', 'dark:bg-gray-700');
            
            renderBooks();
        }

        // Sort books
        function sortBooks() {
            renderBooks();
        }

        // Update book selector
        function updateBookSelector() {
            elements.bookSelector.innerHTML = '<option value="">Select a book</option>';
            
            const incompleteBooks = appState.books.filter(book => !book.completed);
            
            incompleteBooks.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = `${book.title} (${book.currentPage}/${book.totalPages})`;
                elements.bookSelector.appendChild(option);
            });
            
            if (incompleteBooks.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No active books (add one in Books tab)';
                option.disabled = true;
                elements.bookSelector.appendChild(option);
            }
            
            // Also update history book selector
            if (elements.historyBook) {
                elements.historyBook.innerHTML = '<option value="all">All Books</option>';
                
                appState.books.forEach(book => {
                    const option = document.createElement('option');
                    option.value = book.id;
                    option.textContent = book.title;
                    elements.historyBook.appendChild(option);
                });
            }
        }

        // Render stats
        function renderStats() {
            // Update stats values
            elements.totalPagesRead.textContent = appState.stats.totalPagesRead;
            elements.daysTracked.textContent = appState.stats.daysTracked;
            elements.avgPagesPerDay.textContent = appState.stats.daysTracked > 0 ? Math.round(appState.stats.totalPagesRead / appState.stats.daysTracked) : 0;
            elements.longestStreak.textContent = appState.stats.longestStreak;
            elements.booksCompleted.textContent = appState.stats.booksCompleted;
            elements.prestigeLevel.textContent = appState.stats.prestigeLevel;
            
            // Update extended stats
            if (elements.maxPagesDay) {
                elements.maxPagesDay.textContent = appState.extendedStats.maxPagesInOneDay;
                elements.totalBufferEarned.textContent = appState.extendedStats.totalBufferPagesEarned;
                elements.uniqueGenres.textContent = appState.extendedStats.readGenres.size;
                elements.freePassesUsed.textContent = appState.extendedStats.freePassesUsed;
                elements.streakCyclesCompleted.textContent = appState.extendedStats.totalStreakCyclesCompleted;
                
                // Calculate average book completion time
                calculateAverageCompletionTime();
            }
            
            // Create charts
            renderReadingChart();
            renderWeeklyPatternChart();
            renderReadingTimeline();
            
            // Render streak calendar
            renderStreakCalendar();
        }

        // Calculate average book completion time
        function calculateAverageCompletionTime() {
            const completedBooks = appState.books.filter(book => book.completed && book.dateAdded && book.dateCompleted);
            
            if (completedBooks.length === 0) {
                elements.avgCompletionTime.textContent = 'N/A';
                return;
            }
            
            let totalDays = 0;
            
            completedBooks.forEach(book => {
                const startDate = new Date(book.dateAdded);
                const endDate = new Date(book.dateCompleted);
                const daysDiff = Math.round((endDate - startDate) / (1000 * 60 * 60 * 24));
                totalDays += daysDiff;
            });
            
            const avgDays = Math.round(totalDays / completedBooks.length);
            
            if (avgDays === 0) {
                elements.avgCompletionTime.textContent = '< 1 day';
            } else if (avgDays === 1) {
                elements.avgCompletionTime.textContent = '1 day';
            } else if (avgDays < 30) {
                elements.avgCompletionTime.textContent = `${avgDays} days`;
            } else {
                const months = Math.round(avgDays / 30);
                elements.avgCompletionTime.textContent = `${months} ${months === 1 ? 'month' : 'months'}`;
            }
        }

        // Render reading chart
        function renderReadingChart() {
            if (!elements.readingChart) return;
            
            const chartCtx = elements.readingChart.getContext('2d');
            
            // Get filter values
            const period = parseInt(elements.historyPeriod.value) || 30;
            const bookId = elements.historyBook.value;
            const grouping = elements.historyGrouping.value;
            
            // Prepare data based on filters
            let readingData = {};
            let labels = [];
            
            // Define end date as today
            const endDate = new Date();
            endDate.setHours(0, 0, 0, 0);
            
            // Define start date based on period
            const startDate = new Date(endDate);
            if (period !== 'all') {
                startDate.setDate(startDate.getDate() - period);
            } else {
                // For "all", get the first reading date or 1 year ago, whichever is later
                const firstReadingDate = appState.stats.readingHistory.length > 0 ?
                    new Date(appState.stats.readingHistory[0].date) :
                    new Date(endDate);
                firstReadingDate.setHours(0, 0, 0, 0);
                
                const oneYearAgo = new Date(endDate);
                oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
                
                if (firstReadingDate > oneYearAgo) {
                    startDate.setTime(firstReadingDate.getTime());
                } else {
                    startDate.setTime(oneYearAgo.getTime());
                }
            }
            
            // Filter reading history based on date range and book
            let filteredHistory = appState.stats.readingHistory.filter(entry => {
                const entryDate = new Date(entry.date);
                entryDate.setHours(0, 0, 0, 0);
                
                return entryDate >= startDate && entryDate <= endDate && 
                    (bookId === 'all' || entry.bookId === bookId);
            });
            
            // Group data based on selected grouping
            if (grouping === 'day') {
                // Daily grouping - create array of dates in range
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    const dateString = d.toDateString();
                    labels.push(formatDate(d, 'short'));
                    readingData[dateString] = 0;
                }
                
                // Sum pages by day
                filteredHistory.forEach(entry => {
                    const dateString = new Date(entry.date).toDateString();
                    if (readingData[dateString] !== undefined) {
                        readingData[dateString] += entry.pages;
                    }
                });
            } else if (grouping === 'week') {
                // Weekly grouping
                const weeks = {};
                let weekStart = new Date(startDate);
                weekStart.setDate(weekStart.getDate() - weekStart.getDay()); // Set to start of week (Sunday)
                
                while (weekStart <= endDate) {
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekStart.getDate() + 6);
                    
                    const weekKey = weekStart.toDateString();
                    const weekLabel = `${formatDate(weekStart, 'short')} - ${formatDate(weekEnd, 'short')}`;
                    
                    weeks[weekKey] = {
                        label: weekLabel,
                        total: 0
                    };
                    
                    weekStart = new Date(weekStart);
                    weekStart.setDate(weekStart.getDate() + 7);
                }
                
                // Sum pages by week
                filteredHistory.forEach(entry => {
                    const entryDate = new Date(entry.date);
                    const weekStart = new Date(entryDate);
                    weekStart.setDate(entryDate.getDate() - entryDate.getDay());
                    
                    const weekKey = weekStart.toDateString();
                    if (weeks[weekKey]) {
                        weeks[weekKey].total += entry.pages;
                    }
                });
                
                // Convert to arrays for chart
                Object.entries(weeks).forEach(([key, data]) => {
                    labels.push(data.label);
                    readingData[key] = data.total;
                });
            } else if (grouping === 'month') {
                // Monthly grouping
                const months = {};
                let monthStart = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
                
                while (monthStart <= endDate) {
                    const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);
                    
                    const monthKey = monthStart.toDateString();
                    const monthLabel = monthStart.toLocaleDateString('default', { month: 'short', year: 'numeric' });
                    
                    months[monthKey] = {
                        label: monthLabel,
                        total: 0
                    };
                    
                    monthStart = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 1);
                }
                
                // Sum pages by month
                filteredHistory.forEach(entry => {
                    const entryDate = new Date(entry.date);
                    const monthStart = new Date(entryDate.getFullYear(), entryDate.getMonth(), 1);
                    
                    const monthKey = monthStart.toDateString();
                    if (months[monthKey]) {
                        months[monthKey].total += entry.pages;
                    }
                });
                
                // Convert to arrays for chart
                Object.entries(months).forEach(([key, data]) => {
                    labels.push(data.label);
                    readingData[key] = data.total;
                });
            }
            
            // Extract values for chart in the same order as labels
            const values = labels.map((label, index) => {
                if (grouping === 'day') {
                    const dateString = new Date(startDate);
                    dateString.setDate(startDate.getDate() + index);
                    return readingData[dateString.toDateString()] || 0;
                } else {
                    // For week and month, the readingData key is stored with the corresponding data
                    const keys = Object.keys(readingData);
                    return index < keys.length ? readingData[keys[index]] : 0;
                }
            });
            
            // Create or update chart
            if (window.readingChart) {
                window.readingChart.data.labels = labels;
                window.readingChart.data.datasets[0].data = values;
                window.readingChart.update();
            } else {
                window.readingChart = new Chart(chartCtx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Pages Read',
                            data: values,
                            backgroundColor: '#5D5CDE',
                            borderColor: '#5D5CDE',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 5
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        return tooltipItems[0].label;
                                    },
                                    label: function(context) {
                                        return `Pages: ${context.raw}`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        // Format date for display
        function formatDate(date, style = 'full') {
            if (style === 'short') {
                return `${date.getMonth() + 1}/${date.getDate()}`;
            } else if (style === 'medium') {
                return date.toLocaleDateString('default', { month: 'short', day: 'numeric' });
            } else {
                return date.toLocaleDateString();
            }
        }

        // Render weekly pattern chart
        function renderWeeklyPatternChart() {
            if (!elements.weeklyPatternChart) return;
            
            const chartCtx = elements.weeklyPatternChart.getContext('2d');
            
            // Initialize array for days of week (0 = Sunday, 6 = Saturday)
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const pagesByDay = [0, 0, 0, 0, 0, 0, 0];
            const countsByDay = [0, 0, 0, 0, 0, 0, 0];
            
            // Sum pages by day of week
            appState.stats.readingHistory.forEach(entry => {
                const date = new Date(entry.date);
                const dayOfWeek = date.getDay();
                
                pagesByDay[dayOfWeek] += entry.pages;
                countsByDay[dayOfWeek]++;
            });
            
            // Calculate average pages per day of week
            const avgPagesByDay = pagesByDay.map((total, index) => 
                countsByDay[index] > 0 ? Math.round(total / countsByDay[index]) : 0
            );
            
            // Create or update chart
            if (window.weeklyPatternChart) {
                window.weeklyPatternChart.data.datasets[0].data = avgPagesByDay;
                window.weeklyPatternChart.update();
            } else {
                window.weeklyPatternChart = new Chart(chartCtx, {
                    type: 'bar',
                    data: {
                        labels: daysOfWeek,
                        datasets: [{
                            label: 'Avg. Pages',
                            data: avgPagesByDay,
                            backgroundColor: [
                                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                                '#9966FF', '#FF9F40', '#5D5CDE'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    precision: 0
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const index = context.dataIndex;
                                        const totalReads = countsByDay[index];
                                        return [
                                            `Avg. Pages: ${context.raw}`,
                                            `Reading Days: ${totalReads}`
                                        ];
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        // Render reading timeline
        function renderReadingTimeline() {
            if (!elements.readingTimeline) return;
            
            elements.readingTimeline.innerHTML = '';
            
            // Get completed books
            const completedBooks = appState.books
                .filter(book => book.completed && book.dateAdded && book.dateCompleted)
                .sort((a, b) => new Date(a.dateAdded) - new Date(b.dateAdded));
            
            if (completedBooks.length === 0) {
                elements.readingTimeline.innerHTML = '<p class="text-center text-gray-600 dark:text-gray-400 py-4">No completed books to display.</p>';
                return;
            }
            
            // Find date range
            const startDate = new Date(completedBooks[0].dateAdded);
            const endDate = new Date(Math.max(
                ...completedBooks.map(book => new Date(book.dateCompleted).getTime()),
                new Date().getTime()
            ));
            
            // Add a small margin to the date range
            startDate.setDate(startDate.getDate() - 7);
            endDate.setDate(endDate.getDate() + 7);
            
            const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            const timelineWidth = Math.max(1000, totalDays * 10); // Ensure enough width
            
            // Create SVG container with D3
            const svg = d3.select(elements.readingTimeline)
                .append('svg')
                .attr('width', timelineWidth)
                .attr('height', 250);
                
            // Create scale for dates
            const xScale = d3.scaleTime()
                .domain([startDate, endDate])
                .range([50, timelineWidth - 50]);
                
            // Add axis
            const xAxis = d3.axisBottom(xScale)
                .ticks(d3.timeMonth.every(1))
                .tickFormat(d3.timeFormat('%b %Y'));
                
            svg.append('g')
                .attr('transform', 'translate(0, 220)')
                .call(xAxis);
                
            // Add books to timeline
            const bookHeight = 20;
            const bookGap = 5;
            const bookRows = [];
            
            completedBooks.forEach((book, i) => {
                const startX = xScale(new Date(book.dateAdded));
                const endX = xScale(new Date(book.dateCompleted));
                const width = endX - startX;
                
                // Find a row for this book
                let rowIndex = 0;
                while (rowIndex < bookRows.length) {
                    let canFit = true;
                    for (let existingBook of bookRows[rowIndex]) {
                        // Check if this book overlaps with any book in this row
                        if (
                            (startX >= existingBook.startX && startX <= existingBook.endX) ||
                            (endX >= existingBook.startX && endX <= existingBook.endX) ||
                            (startX <= existingBook.startX && endX >= existingBook.endX)
                        ) {
                            canFit = false;
                            break;
                        }
                    }
                    
                    if (canFit) break;
                    rowIndex++;
                }
                
                // If no row found, create a new one
                if (rowIndex === bookRows.length) {
                    bookRows.push([]);
                }
                
                // Add book to the row
                bookRows[rowIndex].push({ book, startX, endX });
                
                // Calculate Y position
                const y = 20 + rowIndex * (bookHeight + bookGap);
                
                // Get color based on genre
                const color = getColorForGenre(book.genre);
                
                // Draw book bar
                const bookBar = svg.append('rect')
                    .attr('x', startX)
                    .attr('y', y)
                    .attr('width', Math.max(3, width)) // Ensure minimum width for visibility
                    .attr('height', bookHeight)
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('fill', color)
                    .attr('stroke', 'rgba(0,0,0,0.2)')
                    .attr('stroke-width', 1)
                    .style('cursor', 'pointer');
                    
                // Add tooltip on hover
                const daysToComplete = Math.round((new Date(book.dateCompleted) - new Date(book.dateAdded)) / (1000 * 60 * 60 * 24));
                
                const tooltip = d3.select(elements.readingTimeline)
                    .append('div')
                    .attr('class', 'absolute hidden p-2 bg-white dark:bg-dark-background text-sm rounded shadow-lg border border-light-border dark:border-dark-border')
                    .style('pointer-events', 'none');
                    
                bookBar.on('mouseover', function(event) {
                    tooltip
                        .html(`
                            <div class="font-bold">${book.title}</div>
                            <div class="text-xs">${book.author || 'Unknown Author'}</div>
                            <div class="text-xs">${book.genre || 'No Genre'} ‚Ä¢ ${book.totalPages} pages</div>
                            <div class="text-xs mt-1">Started: ${new Date(book.dateAdded).toLocaleDateString()}</div>
                            <div class="text-xs">Completed: ${new Date(book.dateCompleted).toLocaleDateString()}</div>
                            <div class="text-xs font-medium ${daysToComplete <= 7 ? 'text-success' : daysToComplete > 30 ? 'text-danger' : ''}">
                                Time to complete: ${daysToComplete} days
                            </div>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY + 10) + 'px')
                        .classed('hidden', false);
                })
                .on('mousemove', function(event) {
                    tooltip
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY + 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.classed('hidden', true);
                });
                
                // Add title for very wide books
                if (width > 100) {
                    svg.append('text')
                        .attr('x', startX + 5)
                        .attr('y', y + bookHeight / 2 + 4)
                        .attr('fill', isLightColor(color) ? '#000000' : '#ffffff')
                        .style('font-size', '9px')
                        .style('pointer-events', 'none')
                        .text(truncateText(book.title, width / 6));
                }
            });
            
            // Add vertical line for today
            const today = new Date();
            if (today >= startDate && today <= endDate) {
                const todayX = xScale(today);
                
                svg.append('line')
                    .attr('x1', todayX)
                    .attr('y1', 20)
                    .attr('x2', todayX)
                    .attr('y2', 220)
                    .attr('stroke', '#FF0000')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,3');
                    
                svg.append('text')
                    .attr('x', todayX)
                    .attr('y', 15)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#FF0000')
                    .style('font-size', '10px')
                    .text('Today');
            }
        }

        // Helper for timeline - Get color for genre
        function getColorForGenre(genre) {
            if (!genre || genre.trim() === '') return '#AAAAAA';
            
            // Map of genres to colors
            const genreColors = {
                'Fiction': '#4287f5',
                'Non-Fiction': '#f54242',
                'Science Fiction': '#42f5b3',
                'Fantasy': '#9142f5',
                'Biography': '#f59b42',
                'History': '#f5e642',
                'Science': '#42f548',
                'Self-Help': '#f542e3',
                'Business': '#4284f5',
                'Philosophy': '#42f5f5',
                'Psychology': '#b342f5',
                'Romance': '#f54284',
                'Mystery': '#8f42f5',
                'Thriller': '#f54242',
                'Horror': '#000000',
                'Poetry': '#f5429b',
                'Comics': '#42f584',
                'Art': '#f5aa42',
                'Travel': '#42aaf5',
                'Cooking': '#f5e642',
                'Religion': '#f5e642',
                'Children': '#42f5d1',
                'Young Adult': '#f542c0'
            };
            
            // Try to match genre name
            for (const [key, color] of Object.entries(genreColors)) {
                if (genre.toLowerCase().includes(key.toLowerCase())) {
                    return color;
                }
            }
            
            // Generate consistent color based on genre name
            let hash = 0;
            for (let i = 0; i < genre.length; i++) {
                hash = genre.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const hue = hash % 360;
            return `hsl(${hue}, 70%, 60%)`;
        }

        // Helper for timeline - Check if color is light
        function isLightColor(color) {
            // Simple check for light vs dark colors
            if (color.startsWith('#')) {
                const hex = color.substring(1);
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                // Calculate relative luminance
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                return luminance > 0.5;
            }
            
            return false;
        }

        // Helper for timeline - Truncate text
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength - 3) + '...';
        }

        // Render genre chart
        function renderGenreChart() {
            if (!elements.genreChart) return;
            
            // Get all books with genres
            const booksWithGenres = appState.books.filter(book => book.genre && book.genre.trim() !== '');
            
            if (booksWithGenres.length === 0) {
                elements.genreChart.parentElement.innerHTML = '<p class="text-center text-gray-600 dark:text-gray-400 py-4">No books with genres to display.</p>';
                return;
            }
            
            // Count books by genre
            const genreCounts = {};
            booksWithGenres.forEach(book => {
                const genre = book.genre.trim();
                if (!genreCounts[genre]) {
                    genreCounts[genre] = {
                        total: 0,
                        completed: 0
                    };
                }
                
                genreCounts[genre].total++;
                if (book.completed) {
                    genreCounts[genre].completed++;
                }
            });
            
            // Prepare data for chart
            const genres = Object.keys(genreCounts).sort((a, b) => genreCounts[b].total - genreCounts[a].total);
            const completedCounts = genres.map(genre => genreCounts[genre].completed);
            const inProgressCounts = genres.map(genre => genreCounts[genre].total - genreCounts[genre].completed);
            
            // Generate colors
            const colors = genres.map((genre, i) => getColorForGenre(genre));
            
            // Create or update chart
            const chartCtx = elements.genreChart.getContext('2d');
            
            if (window.genreChart) {
                window.genreChart.data.labels = genres;
                window.genreChart.data.datasets[0].data = completedCounts;
                window.genreChart.data.datasets[0].backgroundColor = colors;
                window.genreChart.data.datasets[1].data = inProgressCounts;
                window.genreChart.data.datasets[1].backgroundColor = colors.map(color => `${color}80`); // Add transparency
                window.genreChart.update();
            } else {
                window.genreChart = new Chart(chartCtx, {
                    type: 'bar',
                    data: {
                        labels: genres,
                        datasets: [
                            {
                                label: 'Completed',
                                data: completedCounts,
                                backgroundColor: colors,
                                borderWidth: 1
                            },
                            {
                                label: 'In Progress',
                                data: inProgressCounts,
                                backgroundColor: colors.map(color => `${color}80`), // Add transparency
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        scales: {
                            x: {
                                stacked: true,
                                beginAtZero: true,
                                ticks: {
                                    precision: 0
                                }
                            },
                            y: {
                                stacked: true
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        return tooltipItems[0].label;
                                    },
                                    label: function(context) {
                                        const genre = context.label;
                                        const datasetLabel = context.dataset.label;
                                        const count = context.raw;
                                        
                                        return `${datasetLabel}: ${count} books`;
                                    },
                                    footer: function(tooltipItems) {
                                        const genre = tooltipItems[0].label;
                                        const total = genreCounts[genre].total;
                                        return `Total: ${total} books`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Update legend
            updateGenreLegend(genres, colors, genreCounts);
        }

        // Update genre legend
        function updateGenreLegend(genres, colors, genreCounts) {
            if (!elements.genreLegend) return;
            
            elements.genreLegend.innerHTML = '';
            
            // Display top genres in the legend
            const topGenres = genres.slice(0, 9); // Limit to 9 for space
            
            topGenres.forEach((genre, i) => {
                const legendItem = document.createElement('div');
                legendItem.className = 'flex items-center';
                
                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'w-3 h-3 rounded-full mr-2 flex-shrink-0';
                colorSwatch.style.backgroundColor = colors[i];
                
                const label = document.createElement('span');
                label.className = 'truncate';
                label.textContent = `${genre} (${genreCounts[genre].total})`;
                
                legendItem.appendChild(colorSwatch);
                legendItem.appendChild(label);
                elements.genreLegend.appendChild(legendItem);
            });
            
            // Add "Other" category if there are more genres
            if (genres.length > 9) {
                const otherCount = genres.slice(9).reduce((sum, genre) => sum + genreCounts[genre].total, 0);
                
                const otherItem = document.createElement('div');
                otherItem.className = 'flex items-center';
                
                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'w-3 h-3 rounded-full mr-2 flex-shrink-0';
                colorSwatch.style.backgroundColor = '#CCCCCC';
                
                const label = document.createElement('span');
                label.className = 'truncate';
                label.textContent = `Other (${otherCount})`;
                
                otherItem.appendChild(colorSwatch);
                otherItem.appendChild(label);
                elements.genreLegend.appendChild(otherItem);
            }
        }

        // Render streak calendar
        function renderStreakCalendar() {
            elements.streakCalendar.innerHTML = '';
            
            // Create days of week headers
            const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            daysOfWeek.forEach(day => {
                const dayEl = document.createElement('div');
                dayEl.className = 'text-center font-medium';
                dayEl.textContent = day;
                elements.streakCalendar.appendChild(dayEl);
            });
            
            // Get current month
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();
            
            // Get first day of month and total days
            const firstDay = new Date(currentYear, currentMonth, 1).getDay();
            const lastDate = new Date(currentYear, currentMonth + 1, 0).getDate();
            
            // Add blank spaces for days before the 1st
            for (let i = 0; i < firstDay; i++) {
                const blankEl = document.createElement('div');
                elements.streakCalendar.appendChild(blankEl);
            }
            
            // Add days of month
            for (let i = 1; i <= lastDate; i++) {
                const date = new Date(currentYear, currentMonth, i);
                const dateString = date.toDateString();
                
                const dayEl = document.createElement('div');
                dayEl.className = 'text-center py-1 rounded-md';
                
                // Check if date has reading logged
                if (appState.stats.dayStreak[dateString]) {
                    // Get reading amount for the day
                    const dayReadings = appState.stats.readingHistory.filter(entry => 
                        new Date(entry.date).toDateString() === dateString
                    );
                    
                    const pagesRead = dayReadings.reduce((sum, entry) => sum + entry.pages, 0);
                    const targetPages = calculateTargetForDate(date);
                    
                    // Determine color based on pages read
                    let bgClass;
                    if (pagesRead >= targetPages * 2) {
                        bgClass = 'bg-purple-500 text-white'; // Exceptional
                    } else if (pagesRead >= targetPages * 1.5) {
                        bgClass = 'bg-blue-500 text-white'; // Very good
                    } else {
                        bgClass = 'bg-success text-white'; // Met target
                    }
                    
                    dayEl.classList.add(...bgClass.split(' '));
                    dayEl.title = `${dateString}: ${pagesRead} pages read`;
                } else if (dateString === today.toDateString()) {
                    dayEl.classList.add('bg-primary', 'text-white');
                    dayEl.title = 'Today';
                } else if (date > today) {
                    dayEl.classList.add('text-gray-400');
                    dayEl.title = 'Future date';
                } else {
                    dayEl.classList.add('bg-red-100', 'dark:bg-red-900', 'dark:bg-opacity-30');
                    dayEl.title = `${dateString}: No reading logged`;
                }
                
                dayEl.textContent = i;
                elements.streakCalendar.appendChild(dayEl);
            }
        }

        // Calculate target for a specific date (for calendar heatmap)
        function calculateTargetForDate(date) {
            // This is a simplification - in a full implementation you'd
            // need to reconstruct the target based on streak cycles completed
            // up to this date, which is complex
            
            // Default to current target
            return appState.settings.dailyTarget;
        }

        // Check prestige eligibility
        function checkPrestigeEligibility() {
            if (appState.stats.completedStreaks >= 5 && !appState.bonuses.nonPrestigeActive) {
                elements.prestigeCard.classList.remove('hidden');
            } else {
                elements.prestigeCard.classList.add('hidden');
            }
        }

        // Prestige
        function prestige() {
    const selectedBonus = document.querySelector('input[name="prestige-bonus"]:checked');

    if (!selectedBonus) {
        showNotification('Please select a bonus', 'error');
        return;
    }

    // Apply the new daily target if set
    if (appState.settings.nextDailyTarget) {
        appState.settings.dailyTarget = appState.settings.nextDailyTarget;

        // Update maxDailyBuffer as 50% of the new target
        appState.settings.maxDailyBuffer = Math.floor(appState.settings.dailyTarget * 0.5);

        delete appState.settings.nextDailyTarget; // Clear the next target
    }

    // Apply permanent bonus
    const bonusType = selectedBonus.value;

    if (bonusType === 'daily-buffer') {
        appState.bonuses.maxDailyBufferBonus = Math.min(10, appState.bonuses.maxDailyBufferBonus + 1);
    } else if (bonusType === 'buffer-capacity') {
        appState.bonuses.bufferCapacityBonus = Math.min(25, appState.bonuses.bufferCapacityBonus + 2);
    } else if (bonusType === 'decay-reduction') {
        appState.bonuses.decayReductionBonus = Math.min(25, appState.bonuses.decayReductionBonus + 5);
    }

    // Increment prestige level
    appState.stats.prestigeLevel++;

    // Unlock achievement
    if (appState.stats.prestigeLevel === 1) {
        unlockAchievement('prestige-1');
    }

    // Check for higher prestige level achievements
    checkPrestigeLevelAchievements();

    // Reset stats
    appState.stats.streakCounter = 0;
    appState.stats.freePass = 1;
    appState.stats.bufferPages = 0;
    appState.stats.weeklyBufferUses = 0;
    appState.stats.bufferDecayCountdown = appState.settings.bufferDecayDays;
    appState.stats.completedStreaks = 0;

    // Reset extended stats that should be reset
    appState.extendedStats.currentConsecutiveDays = 0;
    appState.extendedStats.streakCyclesWithoutFreePass = 0;

    // Reset non-prestige bonuses
    appState.bonuses.nonPrestigeActive = false;

    // Save state and update UI
    saveAppState();
    renderUI();
    renderStats();
    renderInsights();
    renderMilestones();
    renderNextAchievements();

    // Hide prestige card
    elements.prestigeCard.classList.add('hidden');

    showNotification('Prestige successful! Permanent bonus applied.', 'success');
}

        // Continue without prestige
        function continueWithoutPrestige() {
            // Apply non-prestige bonuses
            appState.bonuses.nonPrestigeActive = true;
            
            // Reset completed streaks
            appState.stats.completedStreaks = 0;
            
            // Save state and update UI
            saveAppState();
            renderUI();
            
            // Hide prestige card
            elements.prestigeCard.classList.add('hidden');
            
            showNotification('You chose to continue without prestiging. Non-prestige bonuses applied!', 'success');
        }

        // Render achievements
        function renderAchievements() {
            if (!elements.achievementsList) return;
            
            // Get active category and filter
            const activeCategory = document.querySelector('.achievement-category.active');
            const category = activeCategory ? activeCategory.getAttribute('data-category') : 'all';
            
            const filterValue = elements.filterAchievements.value;
            const searchText = elements.searchAchievements.value.toLowerCase();
            
            // Filter achievements
            let filteredAchievements = [...appState.achievements];
            
            if (category !== 'all') {
                filteredAchievements = filteredAchievements.filter(a => a.category === category);
            }
            
            if (filterValue === 'unlocked') {
                filteredAchievements = filteredAchievements.filter(a => a.unlocked);
            } else if (filterValue === 'locked') {
                filteredAchievements = filteredAchievements.filter(a => !a.unlocked);
            }
            
            if (searchText) {
                filteredAchievements = filteredAchievements.filter(a => 
                    a.name.toLowerCase().includes(searchText) || 
                    a.description.toLowerCase().includes(searchText)
                );
            }
            
            // Update achievements count
            elements.achievementsCount.textContent = `${appState.achievements.filter(a => a.unlocked).length}/${appState.achievements.length}`;
            
            // Render achievements
            elements.achievementsList.innerHTML = '';
            
            if (filteredAchievements.length === 0) {
                elements.achievementsList.innerHTML = '<p class="text-center text-gray-600 dark:text-gray-400 py-4 col-span-2">No achievements match your filters.</p>';
                return;
            }
            
            filteredAchievements.forEach(achievement => {
                const achievementEl = document.createElement('div');
                achievementEl.className = `p-4 bg-white dark:bg-dark-background rounded-lg shadow-sm border ${achievement.unlocked ? 'border-success' : 'border-light-border dark:border-dark-border opacity-70'}`;
                achievementEl.innerHTML = `
                    <div class="flex items-center mb-2">
                        <div class="text-3xl mr-3">${achievement.icon}</div>
                        <div>
                            <h3 class="font-bold">${achievement.name}</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-400">${achievement.description}</p>
                        </div>
                    </div>
                    <div class="text-right">
                        <span class="text-xs px-2 py-1 rounded-full ${achievement.unlocked ? 'bg-success text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}">
                            ${achievement.unlocked ? 'Unlocked' : 'Locked'}
                        </span>
                    </div>
                `;
                
                elements.achievementsList.appendChild(achievementEl);
            });
        }

        // Filter achievements by category
        function filterAchievementsByCategory(category) {
            renderAchievements();
        }

        // Filter achievements by search text
        function filterAchievementsBySearch() {
            renderAchievements();
        }

        // Filter achievements by status
        function filterAchievementsByStatus() {
            renderAchievements();
        }

        // Render recent achievements
        function renderRecentAchievements() {
            if (!elements.recentAchievements) return;
            
            const unlockedAchievements = appState.achievements
                .filter(a => a.unlocked)
                .sort((a, b) => {
                    // Sort by unlock date if available
                    if (a.unlockedAt && b.unlockedAt) {
                        return new Date(b.unlockedAt) - new Date(a.unlockedAt);
                    }
                    return 0;
                });
            
            if (unlockedAchievements.length === 0) {
                elements.noAchievements.classList.remove('hidden');
                return;
            }
            
            elements.noAchievements.classList.add('hidden');
            elements.recentAchievements.innerHTML = '';
            
            // Show latest 3 achievements
            const recentAchievements = unlockedAchievements.slice(0, 3);
            
            recentAchievements.forEach(achievement => {
                const achievementEl = document.createElement('div');
                achievementEl.className = 'flex items-center p-2 bg-white dark:bg-dark-background rounded-md border border-success';
                
                achievementEl.innerHTML = `
                    <div class="text-2xl mr-3">${achievement.icon}</div>
                    <div>
                        <h3 class="font-medium">${achievement.name}</h3>
                        <p class="text-xs text-gray-600 dark:text-gray-400">${achievement.description}</p>
                    </div>
                `;
                
                elements.recentAchievements.appendChild(achievementEl);
            });
        }

        // Render insights
        function renderInsights() {
            if (!elements.insightsContainer) return;
            
            // Check if we have enough data
            if (appState.stats.daysTracked < 7 || appState.stats.readingHistory.length < 7) {
                elements.noInsights.classList.remove('hidden');
                elements.insightsContainer.innerHTML = '';
                return;
            }
            
            elements.noInsights.classList.add('hidden');
            elements.insightsContainer.innerHTML = '';
            
            // Generate insights
            const insights = [];
            
            // Reading pace insight
            const avgPagesPerDay = appState.stats.daysTracked > 0 ? 
                Math.round(appState.stats.totalPagesRead / appState.stats.daysTracked) : 0;
                
            insights.push({
                title: 'Reading Pace',
                content: `You read an average of ${avgPagesPerDay} pages per day. At this rate, you could finish a 300-page book in ${Math.ceil(300 / avgPagesPerDay)} days.`,
                icon: 'üìö'
            });
            
            // Streak insight
            if (appState.extendedStats.currentConsecutiveDays > 0) {
                insights.push({
                    title: 'Current Streak',
                    content: `You've been reading for ${appState.extendedStats.currentConsecutiveDays} consecutive days! ${
                        appState.extendedStats.currentConsecutiveDays >= appState.extendedStats.longestConsecutiveDays ?
                        'This is your longest streak so far!' :
                        `Your longest streak is ${appState.extendedStats.longestConsecutiveDays} days.`
                    }`,
                    icon: 'üî•'
                });
            }
            
            // Best reading day insight
            if (appState.stats.readingHistory.length >= 7) {
                // Analyze reading history by day of week
                const dayStats = [0, 0, 0, 0, 0, 0, 0].map(() => ({ totalPages: 0, count: 0 }));
                
                appState.stats.readingHistory.forEach(entry => {
                    const date = new Date(entry.date);
                    const dayOfWeek = date.getDay();
                    
                    dayStats[dayOfWeek].totalPages += entry.pages;
                    dayStats[dayOfWeek].count++;
                });
                
                // Calculate average per day and find the best day
                const dayAvgs = dayStats.map((stat, index) => ({
                    day: index,
                    avg: stat.count > 0 ? Math.round(stat.totalPages / stat.count) : 0
                }));
                
                const bestDay = dayAvgs.reduce((best, curr) => curr.avg > best.avg ? curr : best, { day: 0, avg: 0 });
                
                if (bestDay.avg > 0) {
                    const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    insights.push({
                        title: 'Best Reading Day',
                        content: `Your most productive reading day is ${daysOfWeek[bestDay.day]}, when you read an average of ${bestDay.avg} pages.`,
                        icon: 'üìÖ'
                    });
                }
            }
            
            // Recent performance insight
            if (appState.stats.readingHistory.length >= 14) {
                const last7Days = appState.stats.readingHistory.filter(entry => {
                    const entryDate = new Date(entry.date);
                    const sevenDaysAgo = new Date();
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    return entryDate >= sevenDaysAgo;
                });
                
                const prev7Days = appState.stats.readingHistory.filter(entry => {
                    const entryDate = new Date(entry.date);
                    const fourteenDaysAgo = new Date();
                    const sevenDaysAgo = new Date();
                    fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    return entryDate >= fourteenDaysAgo && entryDate < sevenDaysAgo;
                });
                
                if (last7Days.length > 0 && prev7Days.length > 0) {
                    const last7Total = last7Days.reduce((sum, entry) => sum + entry.pages, 0);
                    const prev7Total = prev7Days.reduce((sum, entry) => sum + entry.pages, 0);
                    
                    const percentChange = ((last7Total - prev7Total) / prev7Total) * 100;
                    
                    if (Math.abs(percentChange) >= 10) {
                        insights.push({
                            title: 'Recent Performance',
                            content: percentChange >= 0 ?
                                `You've read ${Math.round(percentChange)}% more pages in the last 7 days compared to the previous week. Great job!` :
                                `You've read ${Math.round(Math.abs(percentChange))}% fewer pages in the last 7 days compared to the previous week.`,
                            icon: percentChange >= 0 ? 'üìà' : 'üìâ'
                        });
                    }
                }
            }
            
            // Genre diversity insight
            if (appState.extendedStats.readGenres.size > 0) {
                insights.push({
                    title: 'Genre Diversity',
                    content: `You've read books from ${appState.extendedStats.readGenres.size} different genres. ${
                        appState.extendedStats.readGenres.size >= 5 ?
                        'You have diverse reading interests!' :
                        'Try exploring more genres to diversify your reading.'
                    }`,
                    icon: 'üé≠'
                });
            }
            
            // Buffer usage insight
            if (appState.extendedStats.totalBufferPagesEarned > 0) {
                insights.push({
                    title: 'Buffer Pages',
                    content: `You've earned a total of ${appState.extendedStats.totalBufferPagesEarned} buffer pages through your extra reading. ${
                        appState.stats.bufferPages > 10 ?
                        'You have a healthy buffer saved up for busy days!' :
                        'Consider reading a bit extra on good days to build your buffer.'
                    }`,
                    icon: 'üè¶'
                });
            }
            
            // Render insights
            if (insights.length === 0) {
                elements.noInsights.classList.remove('hidden');
                return;
            }
            
            insights.forEach(insight => {
                const insightEl = document.createElement('div');
                insightEl.className = 'p-4 bg-white dark:bg-dark-background rounded-lg shadow-sm border border-light-border dark:border-dark-border';
                
                insightEl.innerHTML = `
                    <div class="flex items-start">
                        <div class="text-3xl mr-3">${insight.icon}</div>
                        <div>
                            <h3 class="font-bold">${insight.title}</h3>
                            <p class="text-gray-700 dark:text-gray-300">${insight.content}</p>
                        </div>
                    </div>
                `;
                
                elements.insightsContainer.appendChild(insightEl);
            });
        }

        // Render milestones
        function renderMilestones() {
            if (!elements.pagesMilestoneText) return;
            
            // Pages milestone
            let pagesMilestone = 1000;
            if (appState.stats.totalPagesRead >= 1000) pagesMilestone = 5000;
            if (appState.stats.totalPagesRead >= 5000) pagesMilestone = 10000;
            if (appState.stats.totalPagesRead >= 10000) pagesMilestone = 50000;
            
            const pagesProgress = Math.min(100, Math.round((appState.stats.totalPagesRead / pagesMilestone) * 100));
            elements.pagesMilestoneText.textContent = `${appState.stats.totalPagesRead.toLocaleString()}/${pagesMilestone.toLocaleString()}`;
            elements.pagesMilestoneBar.style.width = `${pagesProgress}%`;
            
            // Books milestone
            let booksMilestone = 10;
            if (appState.stats.booksCompleted >= 10) booksMilestone = 50;
            if (appState.stats.booksCompleted >= 50) booksMilestone = 100;
            if (appState.stats.booksCompleted >= 100) booksMilestone = 500;
            
            const booksProgress = Math.min(100, Math.round((appState.stats.booksCompleted / booksMilestone) * 100));
            elements.booksMilestoneText.textContent = `${appState.stats.booksCompleted}/${booksMilestone}`;
            elements.booksMilestoneBar.style.width = `${booksProgress}%`;
            
            // Streak milestone
            let streakMilestone = 50;
            if (appState.extendedStats.longestConsecutiveDays >= 50) streakMilestone = 100;
            if (appState.extendedStats.longestConsecutiveDays >= 100) streakMilestone = 365;
            if (appState.extendedStats.longestConsecutiveDays >= 365) streakMilestone = 1000;
            
            const streakProgress = Math.min(100, Math.round((appState.extendedStats.currentConsecutiveDays / streakMilestone) * 100));
            elements.streakMilestoneText.textContent = `${appState.extendedStats.currentConsecutiveDays}/${streakMilestone}`;
            elements.streakMilestoneBar.style.width = `${streakProgress}%`;
            
            // Prestige milestone
            let prestigeMilestone = 5;
            if (appState.stats.prestigeLevel >= 5) prestigeMilestone = 10;
            if (appState.stats.prestigeLevel >= 10) prestigeMilestone = 20;
            if (appState.stats.prestigeLevel >= 20) prestigeMilestone = 50;
            
            const prestigeProgress = Math.min(100, Math.round((appState.stats.prestigeLevel / prestigeMilestone) * 100));
            elements.prestigeMilestoneText.textContent = `${appState.stats.prestigeLevel}/${prestigeMilestone}`;
            elements.prestigeMilestoneBar.style.width = `${prestigeProgress}%`;
        }

        // Render next achievements
        function renderNextAchievements() {
            if (!elements.nextAchievements) return;
            
            elements.nextAchievements.innerHTML = '';
            
            // Find locked achievements that are closest to being unlocked
            const nextAchievements = [];
            
            // Find achievement with progress tracker
            const lockedAchievements = appState.achievements.filter(a => !a.unlocked);
            
            // Add achievements with progress
            // Pages achievements
            if (!appState.achievements.find(a => a.id === 'pages-100').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'pages-100'),
                    progress: Math.min(100, (appState.stats.totalPagesRead / 100) * 100),
                    label: `${appState.stats.totalPagesRead}/100 pages`
                });
            } else if (!appState.achievements.find(a => a.id === 'pages-1000').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'pages-1000'),
                    progress: Math.min(100, (appState.stats.totalPagesRead / 1000) * 100),
                    label: `${appState.stats.totalPagesRead}/1,000 pages`
                });
            }
            
            // Books achievements
            if (!appState.achievements.find(a => a.id === 'books-50').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'books-50'),
                    progress: Math.min(100, (appState.stats.booksCompleted / 50) * 100),
                    label: `${appState.stats.booksCompleted}/50 books`
                });
            } else if (!appState.achievements.find(a => a.id === 'books-100').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'books-100'),
                    progress: Math.min(100, (appState.stats.booksCompleted / 100) * 100),
                    label: `${appState.stats.booksCompleted}/100 books`
                });
            }
            
            // Consecutive days achievements
            if (!appState.achievements.find(a => a.id === 'consecutive-50').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'consecutive-50'),
                    progress: Math.min(100, (appState.extendedStats.currentConsecutiveDays / 50) * 100),
                    label: `${appState.extendedStats.currentConsecutiveDays}/50 days`
                });
            } else if (!appState.achievements.find(a => a.id === 'consecutive-100').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'consecutive-100'),
                    progress: Math.min(100, (appState.extendedStats.currentConsecutiveDays / 100) * 100),
                    label: `${appState.extendedStats.currentConsecutiveDays}/100 days`
                });
            }
            
            // Genres achievements
            if (!appState.achievements.find(a => a.id === 'genres-5').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'genres-5'),
                    progress: Math.min(100, (appState.extendedStats.readGenres.size / 5) * 100),
                    label: `${appState.extendedStats.readGenres.size}/5 genres`
                });
            } else if (!appState.achievements.find(a => a.id === 'genres-10').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'genres-10'),
                    progress: Math.min(100, (appState.extendedStats.readGenres.size / 10) * 100),
                    label: `${appState.extendedStats.readGenres.size}/10 genres`
                });
            }
            
            // Prestige achievements
            if (!appState.achievements.find(a => a.id === 'prestige-5').unlocked && appState.stats.prestigeLevel > 0) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'prestige-5'),
                    progress: Math.min(100, (appState.stats.prestigeLevel / 5) * 100),
                    label: `${appState.stats.prestigeLevel}/5 prestige levels`
                });
            }
            
            // Daily reading achievements
            if (!appState.achievements.find(a => a.id === 'pages-day-50').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'pages-day-50'),
                    progress: Math.min(100, (appState.extendedStats.maxPagesInOneDay / 50) * 100),
                    label: `${appState.extendedStats.maxPagesInOneDay}/50 pages in a day`
                });
            } else if (!appState.achievements.find(a => a.id === 'pages-day-100').unlocked) {
                nextAchievements.push({
                    achievement: appState.achievements.find(a => a.id === 'pages-day-100'),
                    progress: Math.min(100, (appState.extendedStats.maxPagesInOneDay / 100) * 100),
                    label: `${appState.extendedStats.maxPagesInOneDay}/100 pages in a day`
                });
            }
            
            // Sort by progress (highest first)
            nextAchievements.sort((a, b) => b.progress - a.progress);
            
            // Take top 3
            const topNext = nextAchievements.slice(0, 3);
            
            if (topNext.length === 0) {
                elements.nextAchievements.innerHTML = '<p class="text-center text-gray-600 dark:text-gray-400 py-4">You\'ve unlocked all achievements!</p>';
                return;
            }
            
            // Render achievements
            topNext.forEach(item => {
                const achievementEl = document.createElement('div');
                achievementEl.className = 'p-4 bg-white dark:bg-dark-background rounded-lg shadow-sm border border-light-border dark:border-dark-border';
                
                achievementEl.innerHTML = `
                    <div class="flex items-start mb-2">
                        <div class="text-3xl mr-3">${item.achievement.icon}</div>
                        <div class="flex-grow">
                            <h3 class="font-bold">${item.achievement.name}</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-400">${item.achievement.description}</p>
                        </div>
                    </div>
                    <div class="mt-2">
                        <div class="flex justify-between mb-1">
                            <span class="text-sm">${item.label}</span>
                            <span class="text-sm">${Math.round(item.progress)}%</span>
                        </div>
                        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                            <div class="bg-primary rounded-full h-2" style="width: ${item.progress}%"></div>
                        </div>
                    </div>
                `;
                
                elements.nextAchievements.appendChild(achievementEl);
            });
        }
        
        // Settings tab functions
        
        // Update daily target
        function updateDailyTarget() {
    const newTarget = parseInt(elements.settingDailyTarget.value);

    if (isNaN(newTarget) || newTarget < 5) {
        showNotification('Please enter a valid daily target (minimum 5)', 'error');
        return;
    }

    // Set the new target for the next prestige
    appState.settings.nextDailyTarget = newTarget;

    // Calculate maxDailyBuffer as 50% of the new target
    appState.settings.maxDailyBuffer = Math.floor(newTarget * 0.5);

    // Update the message
    showNotification(
        `The new reading target (${newTarget}) and max daily buffer (${appState.settings.maxDailyBuffer}) will apply the next time you prestige. Current target: ${appState.settings.dailyTarget}`,
        'success'
    );

    // Save the updated state
    saveAppState();
}
        
        // Export data
	function showExportModal() {
    	// Convert Sets to Arrays for JSON serialization
    	const stateToExport = JSON.parse(JSON.stringify(appState));
    	if (stateToExport.extendedStats && stateToExport.extendedStats.readGenres instanceof Set) {
        	stateToExport.extendedStats.readGenres = [...appState.extendedStats.readGenres];
    	}
    
    	// Convert the state to a JSON string
  	  const jsonString = JSON.stringify(stateToExport);

	// Encode the JSON string to Base64
    	const exportString = btoa(encodeURIComponent(jsonString));

	// Set the value of the textarea
    	elements.exportDataText.value = exportString;

	// Show modal by removing the hidden class
    	elements.exportModal.classList.remove('hidden');
	}

	// Hide export modal
	function hideExportModal() {
    	elements.exportModal.classList.add('hidden');
	}

	// Copy export data to clipboard
	function copyExportDataToClipboard() {
	    elements.exportDataText.select();
    	document.execCommand('copy');
    	showNotification('Data copied to clipboard!', 'success');
	}

	// Event listeners
	elements.exportData.addEventListener('click', showExportModal);
	elements.closeExportModal.addEventListener('click', hideExportModal);
	elements.copyExportData.addEventListener('click', copyExportDataToClipboard);
	elements.doneExport.addEventListener('click', hideExportModal);
        
	// Show import panel
	function showImportPanel() {
    	elements.importContainer.classList.remove('hidden');
	}

	// Hide import panel
	function hideImportPanel() {
    	elements.importContainer.classList.add('hidden');
    	elements.importDataText.value = '';
	}

	// Import user data
function importUserData() {
    const importString = elements.importDataText.value.trim();

    if (!importString) {
        showNotification('Please enter valid export data', 'error');
        return;
    }

    try {
        // Decode the Base64 string
        const decodedString = atob(importString);

        // Decode the URI component to get the original JSON string
        const jsonString = decodeURIComponent(decodedString);

        // Parse the JSON string
        const importedState = JSON.parse(jsonString);

        // Basic validation
        if (!importedState.settings || !importedState.stats || !importedState.achievements) {
            throw new Error('Invalid data format');
        }

        // Confirm import
        showConfirmationModal(
            'Confirm Import',
            'This will replace all your current data. Are you sure you want to proceed?',
            () => {
                // Restore Set objects which get serialized as arrays
                if (importedState.extendedStats && Array.isArray(importedState.extendedStats.readGenres)) {
                    importedState.extendedStats.readGenres = new Set(importedState.extendedStats.readGenres);
                }

                // Apply imported state
                Object.assign(appState, importedState);

                // Save to local storage
                saveAppState();

                // Update UI
                renderUI();
                renderBooks();
                renderAchievements();
                renderStats();
                renderInsights();
                renderMilestones();
                renderNextAchievements();
                renderRecentAchievements();
                checkPrestigeEligibility();

                // Close import panel
                hideImportPanel();

                showNotification('Data imported successfully!', 'success');
            }
        );
    } catch (error) {
        showNotification('Error importing data: ' + error.message, 'error');
    }
}
        
        // Reset data
        function confirmResetData() {
            showConfirmationModal(
                'Reset All Data',
                'This will permanently delete all your reading data and achievements. This action cannot be undone. Are you sure you want to proceed?',
                resetData
            );
        }
        
        // Reset all data
        function resetData() {
            // Reset app state to defaults
            appState.settings = {
                dailyTarget: 10,
                streakCycle: 10,
                maxBuffer: 20,
                maxDailyBuffer: 5,
                maxBufferUses: 2,
                bufferDecayDays: 14,
                bufferDecayPercent: 50
            };
            
            appState.stats = {
                streakCounter: 0,
                freePass: 1,
                bufferPages: 0,
                weeklyBufferUses: 0,
                bufferDecayCountdown: 14,
                completedStreaks: 0,
                prestigeLevel: 0,
                totalPagesRead: 0,
                daysTracked: 0,
                longestStreak: 0,
                booksCompleted: 0,
                lastLogDate: null,
                readingHistory: [],
                dayStreak: {}
            };
            
            appState.extendedStats = {
                longestConsecutiveDays: 0,
                currentConsecutiveDays: 0,
                maxPagesInOneDay: 0,
                totalBufferPagesEarned: 0,
                freePassesUsed: 0,
                totalStreakCyclesCompleted: 0,
                readGenres: new Set(),
                lastCompletedStreak: null,
                streakCyclesWithoutFreePass: 0,
                appVersion: '1.1.0'
            };
            
            appState.bonuses = {
                maxDailyBufferBonus: 0,
                bufferCapacityBonus: 0,
                decayReductionBonus: 0,
                nonPrestigeActive: false
            };
            
            appState.books = [];
            
            // Reset achievements
            appState.achievements.forEach(achievement => {
                achievement.unlocked = false;
                if (achievement.unlockedAt) delete achievement.unlockedAt;
            });
            
            // Save reset state
            saveAppState();
            
            // Update UI
            renderUI();
            renderBooks();
            renderAchievements();
            renderStats();
            renderInsights();
            renderMilestones();
            renderNextAchievements();
            renderRecentAchievements();
            
            showNotification('All data has been reset', 'success');
        }
        
        // Show confirmation modal
        function showConfirmationModal(title, message, confirmCallback) {
            elements.confirmationTitle.textContent = title;
            elements.confirmationMessage.textContent = message;
            
            // Set confirm action
            elements.confirmAction.onclick = () => {
                hideConfirmationModal();
                if (confirmCallback) confirmCallback();
            };
            
            // Show modal
            elements.confirmationModal.classList.remove('hidden');
        }
        
        // Hide confirmation modal
        function hideConfirmationModal() {
            elements.confirmationModal.classList.add('hidden');
        }

        // Unlock achievement
        function unlockAchievement(achievementId) {
            const achievement = appState.achievements.find(a => a.id === achievementId);
            
            if (achievement && !achievement.unlocked) {
                achievement.unlocked = true;
                achievement.unlockedAt = new Date().toISOString();
                showNotification(`Achievement Unlocked: ${achievement.name}`, 'success', achievement.icon);
                
                // Check for achievement hunter
                checkAchievementHunter();
                
                // Check for prestige collector
                checkPrestigeCollector();
                
                saveAppState();
                renderRecentAchievements();
            }
        }

        // Check achievement conditions
        
        // Check pages achievements
        function checkPagesAchievements() {
            if (appState.stats.totalPagesRead >= 100 && !appState.achievements.find(a => a.id === 'pages-100').unlocked) {
                unlockAchievement('pages-100');
            }
            
            if (appState.stats.totalPagesRead >= 1000 && !appState.achievements.find(a => a.id === 'pages-1000').unlocked) {
                unlockAchievement('pages-1000');
            }
        }
        
        // Check pages in one day achievements
        function checkPagesInOneDayAchievements() {
            if (appState.extendedStats.maxPagesInOneDay >= 50 && !appState.achievements.find(a => a.id === 'pages-day-50').unlocked) {
                unlockAchievement('pages-day-50');
            }
            
            if (appState.extendedStats.maxPagesInOneDay >= 100 && !appState.achievements.find(a => a.id === 'pages-day-100').unlocked) {
                unlockAchievement('pages-day-100');
            }
        }
        
        // Check book count achievements
        function checkBookCountAchievements() {
            if (appState.stats.booksCompleted >= 50 && !appState.achievements.find(a => a.id === 'books-50').unlocked) {
                unlockAchievement('books-50');
            }
            
            if (appState.stats.booksCompleted >= 100 && !appState.achievements.find(a => a.id === 'books-100').unlocked) {
                unlockAchievement('books-100');
            }
            
            if (appState.stats.booksCompleted >= 500 && !appState.achievements.find(a => a.id === 'books-500').unlocked) {
                unlockAchievement('books-500');
            }
        }
        
        // Check genre count achievements
        function checkGenreCountAchievements() {
            if (appState.extendedStats.readGenres.size >= 5 && !appState.achievements.find(a => a.id === 'genres-5').unlocked) {
                unlockAchievement('genres-5');
            }
            
            if (appState.extendedStats.readGenres.size >= 10 && !appState.achievements.find(a => a.id === 'genres-10').unlocked) {
                unlockAchievement('genres-10');
            }
        }
        
        // Check consecutive days achievements
        function checkConsecutiveDaysAchievements() {
            if (appState.extendedStats.currentConsecutiveDays >= 50 && !appState.achievements.find(a => a.id === 'consecutive-50').unlocked) {
                unlockAchievement('consecutive-50');
            }
            
            if (appState.extendedStats.currentConsecutiveDays >= 100 && !appState.achievements.find(a => a.id === 'consecutive-100').unlocked) {
                unlockAchievement('consecutive-100');
            }
            
            if (appState.extendedStats.currentConsecutiveDays >= 365 && !appState.achievements.find(a => a.id === 'consecutive-365').unlocked) {
                unlockAchievement('consecutive-365');
            }
            
            if (appState.extendedStats.currentConsecutiveDays >= 1000 && !appState.achievements.find(a => a.id === 'consecutive-1000').unlocked) {
                unlockAchievement('consecutive-1000');
            }
        }
        
        // Check prestige level achievements
        function checkPrestigeLevelAchievements() {
            if (appState.stats.prestigeLevel >= 5 && !appState.achievements.find(a => a.id === 'prestige-5').unlocked) {
                unlockAchievement('prestige-5');
            }
            
            if (appState.stats.prestigeLevel >= 10 && !appState.achievements.find(a => a.id === 'prestige-10').unlocked) {
                unlockAchievement('prestige-10');
            }
            
            if (appState.stats.prestigeLevel >= 20 && !appState.achievements.find(a => a.id === 'prestige-20').unlocked) {
                unlockAchievement('prestige-20');
            }
            
            if (appState.stats.prestigeLevel >= 50 && !appState.achievements.find(a => a.id === 'prestige-50').unlocked) {
                unlockAchievement('prestige-50');
            }
        }
        
        // Check prestige collector achievement
        function checkPrestigeCollector() {
            const prestigeAchievements = [
                'prestige-1',
                'prestige-5',
                'prestige-10',
                'prestige-20',
                'prestige-50'
            ];
            
            const allUnlocked = prestigeAchievements.every(id => 
                appState.achievements.find(a => a.id === id)?.unlocked
            );
            
            if (allUnlocked && !appState.achievements.find(a => a.id === 'prestige-collector').unlocked) {
                unlockAchievement('prestige-collector');
            }
        }
        
        // Check achievement hunter achievement
        function checkAchievementHunter() {
            // Count all unlocked achievements except the achievement hunter itself
            const unlockedCount = appState.achievements.filter(a => 
                a.id !== 'achievement-hunter' && a.unlocked
            ).length;
            
            // Check if all other achievements are unlocked
            const totalAchievements = appState.achievements.length - 1; // Exclude achievement hunter
            
            if (unlockedCount === totalAchievements && !appState.achievements.find(a => a.id === 'achievement-hunter').unlocked) {
                unlockAchievement('achievement-hunter');
            }
        }

        // Show notification
        function showNotification(message, type, icon = '') {
            const notificationEl = document.createElement('div');
            notificationEl.className = `fixed bottom-4 right-4 px-4 py-3 rounded-md shadow-lg transition-opacity duration-500 ${
                type === 'success' ? 'bg-green-500 text-white' :
                type === 'error' ? 'bg-red-500 text-white' :
                'bg-blue-500 text-white'
            }`;
            
            notificationEl.innerHTML = `${icon} ${message}`;
            document.body.appendChild(notificationEl);
            
            setTimeout(() => {
                notificationEl.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(notificationEl);
                }, 500);
            }, 3000);
        }

        // Edit book (global function)
        window.editBook = function(bookId) {
            const book = appState.books.find(book => book.id === bookId);
            
            if (!book) return;
            
            // Fill form with book data
            elements.bookTitle.value = book.title;
            elements.bookAuthor.value = book.author || '';
            elements.bookGenre.value = book.genre || '';
            elements.bookTotalPages.value = book.totalPages;
            elements.bookCurrentPage.value = book.currentPage;
            
            // Remove book
            appState.books = appState.books.filter(b => b.id !== bookId);
            
            // Update UI
            saveAppState();
            renderBooks();
            renderGenreChart();
            updateBookSelector();
            
            // Switch to books tab
            document.querySelector('.tab-btn[data-tab="books"]').click();
            
            // Scroll to form
            document.getElementById('add-book-form').scrollIntoView({ behavior: 'smooth' });
            
            // Show notification
            showNotification('Book loaded for editing', 'success');
        };

        // Delete book (global function)
        window.deleteBook = function(bookId) {
            const book = appState.books.find(book => book.id === bookId);
            
            if (!book) return;
            
            const wasCompleted = book.completed;
            
            // Remove book
            appState.books = appState.books.filter(b => b.id !== bookId);
            
            // Update completed books count
            if (wasCompleted && appState.stats.booksCompleted > 0) {
                appState.stats.booksCompleted--;
            }
            
            // Update UI
            saveAppState();
            renderBooks();
            renderGenreChart();
            updateBookSelector();
            renderStats();
            renderInsights();
            renderMilestones();
            
            // Show notification
            showNotification('Book deleted', 'success');
        };

        // Add CSS classes for active tab
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                .tab-btn {
                    position: relative;
                    color: var(--tw-text-opacity-1, rgba(107, 114, 128, 1));
                }
                
                .tab-btn:hover {
                    color: var(--tw-primary, #5D5CDE);
                }
                
                .tab-btn.active {
                    color: var(--tw-primary, #5D5CDE);
                    font-weight: 600;
                }
                
                .tab-btn.active::after {
                    content: '';
                    position: absolute;
                    bottom: -1px;
                    left: 0;
                    right: 0;
                    height: 2px;
                    background-color: var(--tw-primary, #5D5CDE);
                }
                
                .stat-box {
                    display: flex;
                    flex-direction: column;
                    padding: 0.75rem;
                    border-radius: 0.5rem;
                    background-color: rgba(0, 0, 0, 0.03);
                }
                
                .dark .stat-box {
                    background-color: rgba(255, 255, 255, 0.05);
                }
                
                .filter-btn, .achievement-category {
                    transition: all 0.2s ease;
                }
                
                /* Remove margins from Chart.js */
                canvas {
                    display: block;
                }
                
                @media (prefers-color-scheme: dark) {
                    .dark\:bg-dark-background {
                        background-color: #181818;
                    }
                    
                    .dark\:bg-dark-card {
                        background-color: #262626;
                    }
                    
                    .dark\:text-dark-text {
                        color: #E0E0E0;
                    }
                    
                    .dark\:border-dark-border {
                        border-color: #404040;
                    }
                }
            </style>
        `);

        // Initialize the app
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>